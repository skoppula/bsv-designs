//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Wed Nov 22 16:45:58 EST 2017
//
//
// Ports:
// Name                         I/O  size props
// uart_pins_txd                  O     1
// uart_pins_rts                  O     1
// featureRAM_error               O     1 reg
// weightRAM_error                O     1 reg
// uart_errors                    O     3 reg
// cfg                            I    19
// CLK                            I     1 clock
// RST_N                          I     1 reset
// uart_pins_rxd                  I     1
// uart_pins_cts                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBRAMUARTTest(cfg,
		      CLK,
		      RST_N,

		      uart_pins_txd,

		      uart_pins_rxd,

		      uart_pins_rts,

		      uart_pins_cts,

		      featureRAM_error,

		      weightRAM_error,

		      uart_errors);
  input  [18 : 0] cfg;
  input  CLK;
  input  RST_N;

  // value method uart_pins_txd
  output uart_pins_txd;

  // action method uart_pins_rxd
  input  uart_pins_rxd;

  // value method uart_pins_rts
  output uart_pins_rts;

  // action method uart_pins_cts
  input  uart_pins_cts;

  // value method featureRAM_error
  output featureRAM_error;

  // value method weightRAM_error
  output weightRAM_error;

  // value method uart_errors
  output [2 : 0] uart_errors;

  // signals for module outputs
  wire [2 : 0] uart_errors;
  wire featureRAM_error, uart_pins_rts, uart_pins_txd, weightRAM_error;

  // inlined wires
  wire [1 : 0] featureBRAM_serverAdapter_s1_1$wget;
  wire featureBRAM_serverAdapter_cnt_1$whas,
       featureBRAM_serverAdapter_outData_enqData$whas,
       featureBRAM_serverAdapter_outData_outData$whas,
       featureBRAM_serverAdapter_writeWithResp$whas,
       start_wire$whas,
       state_set_pw$whas,
       weightBRAM_serverAdapter_outData_enqData$whas,
       weightBRAM_serverAdapter_outData_outData$whas;

  // register feature
  reg [15 : 0] feature;
  wire [15 : 0] feature$D_IN;
  wire feature$EN;

  // register feature2
  reg [15 : 0] feature2;
  wire [15 : 0] feature2$D_IN;
  wire feature2$EN;

  // register featureBRAM_serverAdapter_cnt
  reg [2 : 0] featureBRAM_serverAdapter_cnt;
  wire [2 : 0] featureBRAM_serverAdapter_cnt$D_IN;
  wire featureBRAM_serverAdapter_cnt$EN;

  // register featureBRAM_serverAdapter_s1
  reg [1 : 0] featureBRAM_serverAdapter_s1;
  wire [1 : 0] featureBRAM_serverAdapter_s1$D_IN;
  wire featureBRAM_serverAdapter_s1$EN;

  // register featureRAM_error_r
  reg featureRAM_error_r;
  wire featureRAM_error_r$D_IN, featureRAM_error_r$EN;

  // register fptr_r
  reg [10 : 0] fptr_r;
  wire [10 : 0] fptr_r$D_IN;
  wire fptr_r$EN;

  // register fptr_w
  reg [10 : 0] fptr_w;
  wire [10 : 0] fptr_w$D_IN;
  wire fptr_w$EN;

  // register i
  reg [31 : 0] i;
  wire [31 : 0] i$D_IN;
  wire i$EN;

  // register jj_1_delay_count
  reg [6 : 0] jj_1_delay_count;
  wire [6 : 0] jj_1_delay_count$D_IN;
  wire jj_1_delay_count$EN;

  // register jj_delay_count
  reg [9 : 0] jj_delay_count;
  wire [9 : 0] jj_delay_count$D_IN;
  wire jj_delay_count$EN;

  // register running
  reg running;
  wire running$D_IN, running$EN;

  // register start_reg
  reg start_reg;
  wire start_reg$D_IN, start_reg$EN;

  // register start_reg_1
  reg start_reg_1;
  wire start_reg_1$D_IN, start_reg_1$EN;

  // register state_can_overlap
  reg state_can_overlap;
  wire state_can_overlap$D_IN, state_can_overlap$EN;

  // register state_fired
  reg state_fired;
  wire state_fired$D_IN, state_fired$EN;

  // register state_mkFSMstate
  reg [4 : 0] state_mkFSMstate;
  reg [4 : 0] state_mkFSMstate$D_IN;
  wire state_mkFSMstate$EN;

  // register weight
  reg [15 : 0] weight;
  wire [15 : 0] weight$D_IN;
  wire weight$EN;

  // register weight2
  reg [15 : 0] weight2;
  wire [15 : 0] weight2$D_IN;
  wire weight2$EN;

  // register weightBRAM_serverAdapter_cnt
  reg [2 : 0] weightBRAM_serverAdapter_cnt;
  wire [2 : 0] weightBRAM_serverAdapter_cnt$D_IN;
  wire weightBRAM_serverAdapter_cnt$EN;

  // register weightBRAM_serverAdapter_s1
  reg [1 : 0] weightBRAM_serverAdapter_s1;
  wire [1 : 0] weightBRAM_serverAdapter_s1$D_IN;
  wire weightBRAM_serverAdapter_s1$EN;

  // register weightRAM_error_r
  reg weightRAM_error_r;
  wire weightRAM_error_r$D_IN, weightRAM_error_r$EN;

  // register wptr_r
  reg [10 : 0] wptr_r;
  wire [10 : 0] wptr_r$D_IN;
  wire wptr_r$EN;

  // register wptr_w
  reg [10 : 0] wptr_w;
  wire [10 : 0] wptr_w$D_IN;
  wire wptr_w$EN;

  // ports of submodule featureBRAM_memory
  wire [15 : 0] featureBRAM_memory$DI, featureBRAM_memory$DO;
  wire [10 : 0] featureBRAM_memory$ADDR;
  wire featureBRAM_memory$EN, featureBRAM_memory$WE;

  // ports of submodule featureBRAM_serverAdapter_outDataCore
  wire [15 : 0] featureBRAM_serverAdapter_outDataCore$D_IN,
		featureBRAM_serverAdapter_outDataCore$D_OUT;
  wire featureBRAM_serverAdapter_outDataCore$CLR,
       featureBRAM_serverAdapter_outDataCore$DEQ,
       featureBRAM_serverAdapter_outDataCore$EMPTY_N,
       featureBRAM_serverAdapter_outDataCore$ENQ,
       featureBRAM_serverAdapter_outDataCore$FULL_N;

  // ports of submodule uart
  reg [7 : 0] uart$tx_i;
  wire [7 : 0] uart$rx;
  wire [2 : 0] uart$errors;
  wire uart$EN_clear,
       uart$EN_rx,
       uart$EN_tx,
       uart$RDY_rx,
       uart$RDY_tx,
       uart$pins_cts,
       uart$pins_rts,
       uart$pins_rxd,
       uart$pins_txd;

  // ports of submodule weightBRAM_memory
  wire [15 : 0] weightBRAM_memory$DI, weightBRAM_memory$DO;
  wire [10 : 0] weightBRAM_memory$ADDR;
  wire weightBRAM_memory$EN, weightBRAM_memory$WE;

  // ports of submodule weightBRAM_serverAdapter_outDataCore
  wire [15 : 0] weightBRAM_serverAdapter_outDataCore$D_IN,
		weightBRAM_serverAdapter_outDataCore$D_OUT;
  wire weightBRAM_serverAdapter_outDataCore$CLR,
       weightBRAM_serverAdapter_outDataCore$DEQ,
       weightBRAM_serverAdapter_outDataCore$EMPTY_N,
       weightBRAM_serverAdapter_outDataCore$ENQ,
       weightBRAM_serverAdapter_outDataCore$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_action_d_init_np,
       WILL_FIRE_RL_action_f_init_l74c25,
       WILL_FIRE_RL_action_f_update_l74c25,
       WILL_FIRE_RL_action_l113c33,
       WILL_FIRE_RL_action_l116c33,
       WILL_FIRE_RL_action_l121c33,
       WILL_FIRE_RL_action_l125c33,
       WILL_FIRE_RL_action_l77c33,
       WILL_FIRE_RL_action_l78c33,
       WILL_FIRE_RL_action_l82c33,
       WILL_FIRE_RL_action_l88c33,
       WILL_FIRE_RL_action_l98c33,
       WILL_FIRE_RL_action_np,
       WILL_FIRE_RL_action_np_1,
       WILL_FIRE_RL_featureBRAM_serverAdapter_outData_enqAndDeq,
       WILL_FIRE_RL_fsm_start,
       WILL_FIRE_RL_idle_l74c25,
       WILL_FIRE_RL_idle_l74c25_1,
       WILL_FIRE_RL_weightBRAM_serverAdapter_outData_enqAndDeq,
       WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_i$write_1__VAL_1;
  wire [15 : 0] MUX_feature$write_1__VAL_1,
		MUX_feature2$write_1__VAL_2,
		MUX_weight$write_1__VAL_2;
  wire [9 : 0] MUX_jj_delay_count$write_1__VAL_1;
  wire [6 : 0] MUX_jj_1_delay_count$write_1__VAL_1;
  wire MUX_start_reg$write_1__SEL_2, MUX_state_mkFSMstate$write_1__SEL_1;

  // remaining internal signals
  reg [63 : 0] v__h47941, v__h50864, v__h51796;
  wire [15 : 0] ftmp__h47927, v__h49315, v__h49403;
  wire [2 : 0] featureBRAM_serverAdapter_cnt_6_PLUS_IF_featur_ETC___d32,
	       weightBRAM_serverAdapter_cnt_5_PLUS_IF_weightB_ETC___d91;
  wire [1 : 0] ab__h1487;
  wire NOT_feature2_23_EQ_feature_91_24___d225,
       NOT_weight2_41_EQ_weight_43_50___d251,
       abort_whas__22_AND_abort_wget__23_24_OR_state__ETC___d274,
       featureBRAM_serverAdapter_cnt_6_SLT_3___d194,
       i_54_ULT_8___d155;

  // value method uart_pins_txd
  assign uart_pins_txd = uart$pins_txd ;

  // value method uart_pins_rts
  assign uart_pins_rts = uart$pins_rts ;

  // value method featureRAM_error
  assign featureRAM_error = featureRAM_error_r ;

  // value method weightRAM_error
  assign weightRAM_error = weightRAM_error_r ;

  // value method uart_errors
  assign uart_errors = uart$errors ;

  // submodule featureBRAM_memory
  BRAM1 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd11),
	  .DATA_WIDTH(32'd16),
	  .MEMSIZE(12'd2048)) featureBRAM_memory(.CLK(CLK),
						 .ADDR(featureBRAM_memory$ADDR),
						 .DI(featureBRAM_memory$DI),
						 .WE(featureBRAM_memory$WE),
						 .EN(featureBRAM_memory$EN),
						 .DO(featureBRAM_memory$DO));

  // submodule featureBRAM_serverAdapter_outDataCore
  SizedFIFO #(.p1width(32'd16),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) featureBRAM_serverAdapter_outDataCore(.RST(RST_N),
								     .CLK(CLK),
								     .D_IN(featureBRAM_serverAdapter_outDataCore$D_IN),
								     .ENQ(featureBRAM_serverAdapter_outDataCore$ENQ),
								     .DEQ(featureBRAM_serverAdapter_outDataCore$DEQ),
								     .CLR(featureBRAM_serverAdapter_outDataCore$CLR),
								     .D_OUT(featureBRAM_serverAdapter_outDataCore$D_OUT),
								     .FULL_N(featureBRAM_serverAdapter_outDataCore$FULL_N),
								     .EMPTY_N(featureBRAM_serverAdapter_outDataCore$EMPTY_N));

  // submodule uart
  mkUARTSpec uart(.cfg(cfg),
		  .CLK(CLK),
		  .RST_N(RST_N),
		  .pins_cts(uart$pins_cts),
		  .pins_rxd(uart$pins_rxd),
		  .tx_i(uart$tx_i),
		  .EN_rx(uart$EN_rx),
		  .EN_tx(uart$EN_tx),
		  .EN_clear(uart$EN_clear),
		  .pins_txd(uart$pins_txd),
		  .pins_rts(uart$pins_rts),
		  .rx_first(),
		  .RDY_rx_first(),
		  .rx(uart$rx),
		  .RDY_rx(uart$RDY_rx),
		  .RDY_tx(uart$RDY_tx),
		  .RDY_clear(),
		  .errors(uart$errors));

  // submodule weightBRAM_memory
  BRAM1Load #(.FILENAME("y.txt"),
	      .PIPELINED(1'd0),
	      .ADDR_WIDTH(32'd11),
	      .DATA_WIDTH(32'd16),
	      .MEMSIZE(12'd2048),
	      .BINARY(1'd0)) weightBRAM_memory(.CLK(CLK),
					       .ADDR(weightBRAM_memory$ADDR),
					       .DI(weightBRAM_memory$DI),
					       .WE(weightBRAM_memory$WE),
					       .EN(weightBRAM_memory$EN),
					       .DO(weightBRAM_memory$DO));

  // submodule weightBRAM_serverAdapter_outDataCore
  SizedFIFO #(.p1width(32'd16),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(32'd1)) weightBRAM_serverAdapter_outDataCore(.RST(RST_N),
								    .CLK(CLK),
								    .D_IN(weightBRAM_serverAdapter_outDataCore$D_IN),
								    .ENQ(weightBRAM_serverAdapter_outDataCore$ENQ),
								    .DEQ(weightBRAM_serverAdapter_outDataCore$DEQ),
								    .CLR(weightBRAM_serverAdapter_outDataCore$CLR),
								    .D_OUT(weightBRAM_serverAdapter_outDataCore$D_OUT),
								    .FULL_N(weightBRAM_serverAdapter_outDataCore$FULL_N),
								    .EMPTY_N(weightBRAM_serverAdapter_outDataCore$EMPTY_N));

  // rule RL_action_d_init_np
  assign WILL_FIRE_RL_action_d_init_np =
	     i_54_ULT_8___d155 &&
	     (state_mkFSMstate == 5'd1 || state_mkFSMstate == 5'd17) ;

  // rule RL_action_np
  assign WILL_FIRE_RL_action_np =
	     !jj_delay_count[9] &&
	     (state_mkFSMstate == 5'd2 || state_mkFSMstate == 5'd3) ;

  // rule RL_action_l77c33
  assign WILL_FIRE_RL_action_l77c33 =
	     jj_delay_count[9] &&
	     (state_mkFSMstate == 5'd2 || state_mkFSMstate == 5'd3) ;

  // rule RL_action_l78c33
  assign WILL_FIRE_RL_action_l78c33 =
	     uart$RDY_rx && state_mkFSMstate == 5'd4 ;

  // rule RL_action_l82c33
  assign WILL_FIRE_RL_action_l82c33 =
	     uart$RDY_rx && state_mkFSMstate == 5'd5 ;

  // rule RL_action_l88c33
  assign WILL_FIRE_RL_action_l88c33 =
	     featureBRAM_serverAdapter_cnt_6_SLT_3___d194 &&
	     state_mkFSMstate == 5'd6 ;

  // rule RL_action_l113c33
  assign WILL_FIRE_RL_action_l113c33 =
	     uart$RDY_tx && state_mkFSMstate == 5'd10 ;

  // rule RL_action_l116c33
  assign WILL_FIRE_RL_action_l116c33 =
	     uart$RDY_tx && state_mkFSMstate == 5'd11 ;

  // rule RL_action_l121c33
  assign WILL_FIRE_RL_action_l121c33 =
	     uart$RDY_tx && state_mkFSMstate == 5'd12 ;

  // rule RL_action_l125c33
  assign WILL_FIRE_RL_action_l125c33 =
	     uart$RDY_tx && state_mkFSMstate == 5'd13 ;

  // rule RL_action_np_1
  assign WILL_FIRE_RL_action_np_1 =
	     jj_1_delay_count != 7'd89 &&
	     (state_mkFSMstate == 5'd15 || state_mkFSMstate == 5'd16) ;

  // rule RL_action_f_update_l74c25
  assign WILL_FIRE_RL_action_f_update_l74c25 =
	     jj_1_delay_count == 7'd89 &&
	     (state_mkFSMstate == 5'd15 || state_mkFSMstate == 5'd16) ;

  // rule RL_fsm_start
  assign WILL_FIRE_RL_fsm_start =
	     abort_whas__22_AND_abort_wget__23_24_OR_state__ETC___d274 &&
	     start_reg ;

  // rule RL_idle_l74c25
  assign WILL_FIRE_RL_idle_l74c25 =
	     !i_54_ULT_8___d155 && !start_wire$whas &&
	     state_mkFSMstate == 5'd1 ;

  // rule RL_idle_l74c25_1
  assign WILL_FIRE_RL_idle_l74c25_1 =
	     !i_54_ULT_8___d155 && !start_wire$whas &&
	     state_mkFSMstate == 5'd17 ;

  // rule RL_action_f_init_l74c25
  assign WILL_FIRE_RL_action_f_init_l74c25 =
	     start_wire$whas && state_mkFSMstate == 5'd0 ||
	     !i_54_ULT_8___d155 && start_wire$whas &&
	     state_mkFSMstate == 5'd1 ||
	     !i_54_ULT_8___d155 && start_wire$whas &&
	     state_mkFSMstate == 5'd17 ;

  // rule RL_weightBRAM_serverAdapter_stageReadResponseAlways
  assign WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways =
	     featureBRAM_serverAdapter_cnt_6_SLT_3___d194 &&
	     (weightBRAM_serverAdapter_cnt ^ 3'h4) < 3'd7 &&
	     state_mkFSMstate == 5'd7 ;

  // rule RL_action_l98c33
  assign WILL_FIRE_RL_action_l98c33 =
	     (featureBRAM_serverAdapter_outDataCore$EMPTY_N ||
	      featureBRAM_serverAdapter_outData_enqData$whas) &&
	     featureBRAM_serverAdapter_outData_outData$whas &&
	     (weightBRAM_serverAdapter_outDataCore$EMPTY_N ||
	      weightBRAM_serverAdapter_outData_enqData$whas) &&
	     weightBRAM_serverAdapter_outData_outData$whas &&
	     state_mkFSMstate == 5'd8 ;

  // rule RL_featureBRAM_serverAdapter_outData_enqAndDeq
  assign WILL_FIRE_RL_featureBRAM_serverAdapter_outData_enqAndDeq =
	     featureBRAM_serverAdapter_outDataCore$EMPTY_N &&
	     featureBRAM_serverAdapter_outDataCore$FULL_N &&
	     WILL_FIRE_RL_action_l98c33 &&
	     featureBRAM_serverAdapter_outData_enqData$whas ;

  // rule RL_weightBRAM_serverAdapter_outData_enqAndDeq
  assign WILL_FIRE_RL_weightBRAM_serverAdapter_outData_enqAndDeq =
	     weightBRAM_serverAdapter_outDataCore$EMPTY_N &&
	     weightBRAM_serverAdapter_outDataCore$FULL_N &&
	     WILL_FIRE_RL_action_l98c33 &&
	     weightBRAM_serverAdapter_outData_enqData$whas ;

  // inputs to muxes for submodule ports
  assign MUX_start_reg$write_1__SEL_2 =
	     abort_whas__22_AND_abort_wget__23_24_OR_state__ETC___d274 &&
	     !start_reg &&
	     !running ;
  assign MUX_state_mkFSMstate$write_1__SEL_1 =
	     WILL_FIRE_RL_idle_l74c25_1 || WILL_FIRE_RL_idle_l74c25 ;
  assign MUX_feature$write_1__VAL_1 = { uart$rx, 8'b0 } ;
  assign MUX_feature2$write_1__VAL_2 = feature2 + 16'd1 ;
  assign MUX_i$write_1__VAL_1 = i + 32'd1 ;
  assign MUX_jj_1_delay_count$write_1__VAL_1 = jj_1_delay_count + 7'd1 ;
  assign MUX_jj_delay_count$write_1__VAL_1 = { jj_delay_count[8:0], 1'd0 } ;
  assign MUX_weight$write_1__VAL_2 = weight + 16'd1 ;

  // inlined wires
  assign featureBRAM_serverAdapter_outData_enqData$whas =
	     (!featureBRAM_serverAdapter_s1[0] ||
	      featureBRAM_serverAdapter_outDataCore$FULL_N) &&
	     featureBRAM_serverAdapter_s1[1] &&
	     featureBRAM_serverAdapter_s1[0] ;
  assign featureBRAM_serverAdapter_outData_outData$whas =
	     featureBRAM_serverAdapter_outDataCore$EMPTY_N ||
	     !featureBRAM_serverAdapter_outDataCore$EMPTY_N &&
	     featureBRAM_serverAdapter_outData_enqData$whas ;
  assign featureBRAM_serverAdapter_cnt_1$whas =
	     (WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	      WILL_FIRE_RL_action_l88c33) &&
	     (!ab__h1487[1] || ab__h1487[0]) ;
  assign featureBRAM_serverAdapter_writeWithResp$whas =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	     WILL_FIRE_RL_action_l88c33 ;
  assign featureBRAM_serverAdapter_s1_1$wget =
	     { 1'd1, !ab__h1487[1] || ab__h1487[0] } ;
  assign weightBRAM_serverAdapter_outData_enqData$whas =
	     (!weightBRAM_serverAdapter_s1[0] ||
	      weightBRAM_serverAdapter_outDataCore$FULL_N) &&
	     weightBRAM_serverAdapter_s1[1] &&
	     weightBRAM_serverAdapter_s1[0] ;
  assign weightBRAM_serverAdapter_outData_outData$whas =
	     weightBRAM_serverAdapter_outDataCore$EMPTY_N ||
	     !weightBRAM_serverAdapter_outDataCore$EMPTY_N &&
	     weightBRAM_serverAdapter_outData_enqData$whas ;
  assign start_wire$whas =
	     WILL_FIRE_RL_fsm_start || start_reg_1 && !state_fired ;
  assign state_set_pw$whas =
	     WILL_FIRE_RL_idle_l74c25_1 || WILL_FIRE_RL_idle_l74c25 ||
	     WILL_FIRE_RL_action_f_update_l74c25 ||
	     WILL_FIRE_RL_action_np_1 ||
	     state_mkFSMstate == 5'd14 ||
	     WILL_FIRE_RL_action_l125c33 ||
	     WILL_FIRE_RL_action_l121c33 ||
	     WILL_FIRE_RL_action_l116c33 ||
	     WILL_FIRE_RL_action_l113c33 ||
	     state_mkFSMstate == 5'd9 ||
	     WILL_FIRE_RL_action_l98c33 ||
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	     WILL_FIRE_RL_action_l88c33 ||
	     WILL_FIRE_RL_action_l82c33 ||
	     WILL_FIRE_RL_action_l78c33 ||
	     WILL_FIRE_RL_action_l77c33 ||
	     WILL_FIRE_RL_action_np ||
	     WILL_FIRE_RL_action_d_init_np ||
	     WILL_FIRE_RL_action_f_init_l74c25 ;

  // register feature
  assign feature$D_IN =
	     WILL_FIRE_RL_action_l78c33 ?
	       MUX_feature$write_1__VAL_1 :
	       ftmp__h47927 ;
  assign feature$EN =
	     WILL_FIRE_RL_action_l78c33 || WILL_FIRE_RL_action_l82c33 ;

  // register feature2
  assign feature2$D_IN =
	     WILL_FIRE_RL_action_l98c33 ?
	       v__h49315 :
	       MUX_feature2$write_1__VAL_2 ;
  assign feature2$EN =
	     WILL_FIRE_RL_action_l98c33 || state_mkFSMstate == 5'd9 ;

  // register featureBRAM_serverAdapter_cnt
  assign featureBRAM_serverAdapter_cnt$D_IN =
	     featureBRAM_serverAdapter_cnt_6_PLUS_IF_featur_ETC___d32 ;
  assign featureBRAM_serverAdapter_cnt$EN =
	     featureBRAM_serverAdapter_cnt_1$whas ||
	     WILL_FIRE_RL_action_l98c33 ;

  // register featureBRAM_serverAdapter_s1
  assign featureBRAM_serverAdapter_s1$D_IN =
	     { featureBRAM_serverAdapter_writeWithResp$whas &&
	       featureBRAM_serverAdapter_s1_1$wget[1],
	       featureBRAM_serverAdapter_s1_1$wget[0] } ;
  assign featureBRAM_serverAdapter_s1$EN = 1'd1 ;

  // register featureRAM_error_r
  assign featureRAM_error_r$D_IN = 1'd1 ;
  assign featureRAM_error_r$EN =
	     state_mkFSMstate == 5'd9 &&
	     NOT_feature2_23_EQ_feature_91_24___d225 ;

  // register fptr_r
  assign fptr_r$D_IN = fptr_r + 11'd1 ;
  assign fptr_r$EN =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ;

  // register fptr_w
  assign fptr_w$D_IN = fptr_w + 11'd1 ;
  assign fptr_w$EN = WILL_FIRE_RL_action_l88c33 ;

  // register i
  assign i$D_IN =
	     WILL_FIRE_RL_action_f_update_l74c25 ?
	       MUX_i$write_1__VAL_1 :
	       32'd0 ;
  assign i$EN =
	     WILL_FIRE_RL_action_f_update_l74c25 ||
	     WILL_FIRE_RL_action_f_init_l74c25 ;

  // register jj_1_delay_count
  assign jj_1_delay_count$D_IN =
	     WILL_FIRE_RL_action_np_1 ?
	       MUX_jj_1_delay_count$write_1__VAL_1 :
	       7'd0 ;
  assign jj_1_delay_count$EN =
	     WILL_FIRE_RL_action_np_1 || state_mkFSMstate == 5'd14 ;

  // register jj_delay_count
  assign jj_delay_count$D_IN =
	     WILL_FIRE_RL_action_np ?
	       MUX_jj_delay_count$write_1__VAL_1 :
	       10'd1 ;
  assign jj_delay_count$EN =
	     WILL_FIRE_RL_action_np || WILL_FIRE_RL_action_d_init_np ;

  // register running
  assign running$D_IN = 1'd1 ;
  assign running$EN = MUX_start_reg$write_1__SEL_2 ;

  // register start_reg
  assign start_reg$D_IN = !WILL_FIRE_RL_fsm_start ;
  assign start_reg$EN =
	     WILL_FIRE_RL_fsm_start ||
	     abort_whas__22_AND_abort_wget__23_24_OR_state__ETC___d274 &&
	     !start_reg &&
	     !running ;

  // register start_reg_1
  assign start_reg_1$D_IN = start_wire$whas ;
  assign start_reg_1$EN = 1'd1 ;

  // register state_can_overlap
  assign state_can_overlap$D_IN = state_set_pw$whas || state_can_overlap ;
  assign state_can_overlap$EN = 1'd1 ;

  // register state_fired
  assign state_fired$D_IN = state_set_pw$whas ;
  assign state_fired$EN = 1'd1 ;

  // register state_mkFSMstate
  always@(MUX_state_mkFSMstate$write_1__SEL_1 or
	  WILL_FIRE_RL_action_f_init_l74c25 or
	  WILL_FIRE_RL_action_d_init_np or
	  WILL_FIRE_RL_action_np or
	  WILL_FIRE_RL_action_l77c33 or
	  WILL_FIRE_RL_action_l78c33 or
	  WILL_FIRE_RL_action_l82c33 or
	  WILL_FIRE_RL_action_l88c33 or
	  WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways or
	  WILL_FIRE_RL_action_l98c33 or
	  state_mkFSMstate or
	  WILL_FIRE_RL_action_l113c33 or
	  WILL_FIRE_RL_action_l116c33 or
	  WILL_FIRE_RL_action_l121c33 or
	  WILL_FIRE_RL_action_l125c33 or
	  WILL_FIRE_RL_action_np_1 or WILL_FIRE_RL_action_f_update_l74c25)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_state_mkFSMstate$write_1__SEL_1: state_mkFSMstate$D_IN = 5'd0;
      WILL_FIRE_RL_action_f_init_l74c25: state_mkFSMstate$D_IN = 5'd1;
      WILL_FIRE_RL_action_d_init_np: state_mkFSMstate$D_IN = 5'd2;
      WILL_FIRE_RL_action_np: state_mkFSMstate$D_IN = 5'd3;
      WILL_FIRE_RL_action_l77c33: state_mkFSMstate$D_IN = 5'd4;
      WILL_FIRE_RL_action_l78c33: state_mkFSMstate$D_IN = 5'd5;
      WILL_FIRE_RL_action_l82c33: state_mkFSMstate$D_IN = 5'd6;
      WILL_FIRE_RL_action_l88c33: state_mkFSMstate$D_IN = 5'd7;
      WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways:
	  state_mkFSMstate$D_IN = 5'd8;
      WILL_FIRE_RL_action_l98c33: state_mkFSMstate$D_IN = 5'd9;
      state_mkFSMstate == 5'd9: state_mkFSMstate$D_IN = 5'd10;
      WILL_FIRE_RL_action_l113c33: state_mkFSMstate$D_IN = 5'd11;
      WILL_FIRE_RL_action_l116c33: state_mkFSMstate$D_IN = 5'd12;
      WILL_FIRE_RL_action_l121c33: state_mkFSMstate$D_IN = 5'd13;
      WILL_FIRE_RL_action_l125c33: state_mkFSMstate$D_IN = 5'd14;
      state_mkFSMstate == 5'd14: state_mkFSMstate$D_IN = 5'd15;
      WILL_FIRE_RL_action_np_1: state_mkFSMstate$D_IN = 5'd16;
      WILL_FIRE_RL_action_f_update_l74c25: state_mkFSMstate$D_IN = 5'd17;
      default: state_mkFSMstate$D_IN = 5'b01010 /* unspecified value */ ;
    endcase
  end
  assign state_mkFSMstate$EN =
	     WILL_FIRE_RL_idle_l74c25_1 || WILL_FIRE_RL_idle_l74c25 ||
	     WILL_FIRE_RL_action_f_init_l74c25 ||
	     WILL_FIRE_RL_action_d_init_np ||
	     WILL_FIRE_RL_action_np ||
	     WILL_FIRE_RL_action_l77c33 ||
	     WILL_FIRE_RL_action_l78c33 ||
	     WILL_FIRE_RL_action_l82c33 ||
	     WILL_FIRE_RL_action_l88c33 ||
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	     WILL_FIRE_RL_action_l98c33 ||
	     state_mkFSMstate == 5'd9 ||
	     WILL_FIRE_RL_action_l113c33 ||
	     WILL_FIRE_RL_action_l116c33 ||
	     WILL_FIRE_RL_action_l121c33 ||
	     WILL_FIRE_RL_action_l125c33 ||
	     state_mkFSMstate == 5'd14 ||
	     WILL_FIRE_RL_action_np_1 ||
	     WILL_FIRE_RL_action_f_update_l74c25 ;

  // register weight
  assign weight$D_IN =
	     WILL_FIRE_RL_action_l116c33 ?
	       i[15:0] :
	       MUX_weight$write_1__VAL_2 ;
  assign weight$EN =
	     WILL_FIRE_RL_action_l116c33 || WILL_FIRE_RL_action_l121c33 ;

  // register weight2
  assign weight2$D_IN = v__h49403 ;
  assign weight2$EN = WILL_FIRE_RL_action_l98c33 ;

  // register weightBRAM_serverAdapter_cnt
  assign weightBRAM_serverAdapter_cnt$D_IN =
	     weightBRAM_serverAdapter_cnt_5_PLUS_IF_weightB_ETC___d91 ;
  assign weightBRAM_serverAdapter_cnt$EN =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	     WILL_FIRE_RL_action_l98c33 ;

  // register weightBRAM_serverAdapter_s1
  assign weightBRAM_serverAdapter_s1$D_IN =
	     { WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways,
	       1'b1 } ;
  assign weightBRAM_serverAdapter_s1$EN = 1'd1 ;

  // register weightRAM_error_r
  assign weightRAM_error_r$D_IN = 1'd1 ;
  assign weightRAM_error_r$EN =
	     WILL_FIRE_RL_action_l125c33 &&
	     NOT_weight2_41_EQ_weight_43_50___d251 ;

  // register wptr_r
  assign wptr_r$D_IN = wptr_r + 11'd1 ;
  assign wptr_r$EN =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ;

  // register wptr_w
  assign wptr_w$D_IN = 11'h0 ;
  assign wptr_w$EN = 1'b0 ;

  // submodule featureBRAM_memory
  assign featureBRAM_memory$ADDR =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ?
	       fptr_r :
	       fptr_w ;
  assign featureBRAM_memory$DI =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ?
	       16'd0 :
	       feature ;
  assign featureBRAM_memory$WE =
	     !WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ;
  assign featureBRAM_memory$EN =
	     featureBRAM_serverAdapter_writeWithResp$whas ;

  // submodule featureBRAM_serverAdapter_outDataCore
  assign featureBRAM_serverAdapter_outDataCore$D_IN = featureBRAM_memory$DO ;
  assign featureBRAM_serverAdapter_outDataCore$ENQ =
	     WILL_FIRE_RL_featureBRAM_serverAdapter_outData_enqAndDeq ||
	     featureBRAM_serverAdapter_outDataCore$FULL_N &&
	     !WILL_FIRE_RL_action_l98c33 &&
	     featureBRAM_serverAdapter_outData_enqData$whas ;
  assign featureBRAM_serverAdapter_outDataCore$DEQ =
	     WILL_FIRE_RL_featureBRAM_serverAdapter_outData_enqAndDeq ||
	     featureBRAM_serverAdapter_outDataCore$EMPTY_N &&
	     WILL_FIRE_RL_action_l98c33 &&
	     !featureBRAM_serverAdapter_outData_enqData$whas ;
  assign featureBRAM_serverAdapter_outDataCore$CLR = 1'b0 ;

  // submodule uart
  assign uart$pins_cts = uart_pins_cts ;
  assign uart$pins_rxd = uart_pins_rxd ;
  always@(WILL_FIRE_RL_action_l116c33 or
	  feature2 or
	  WILL_FIRE_RL_action_l113c33 or
	  WILL_FIRE_RL_action_l125c33 or
	  weight2 or WILL_FIRE_RL_action_l121c33)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_action_l116c33: uart$tx_i = feature2[7:0];
      WILL_FIRE_RL_action_l113c33: uart$tx_i = feature2[15:8];
      WILL_FIRE_RL_action_l125c33: uart$tx_i = weight2[7:0];
      WILL_FIRE_RL_action_l121c33: uart$tx_i = weight2[15:8];
      default: uart$tx_i = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  assign uart$EN_rx =
	     WILL_FIRE_RL_action_l82c33 || WILL_FIRE_RL_action_l78c33 ;
  assign uart$EN_tx =
	     WILL_FIRE_RL_action_l116c33 || WILL_FIRE_RL_action_l113c33 ||
	     WILL_FIRE_RL_action_l125c33 ||
	     WILL_FIRE_RL_action_l121c33 ;
  assign uart$EN_clear = 1'b0 ;

  // submodule weightBRAM_memory
  assign weightBRAM_memory$ADDR = wptr_r ;
  assign weightBRAM_memory$DI = 16'd0 ;
  assign weightBRAM_memory$WE = 1'd0 ;
  assign weightBRAM_memory$EN =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ;

  // submodule weightBRAM_serverAdapter_outDataCore
  assign weightBRAM_serverAdapter_outDataCore$D_IN = weightBRAM_memory$DO ;
  assign weightBRAM_serverAdapter_outDataCore$ENQ =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_outData_enqAndDeq ||
	     weightBRAM_serverAdapter_outDataCore$FULL_N &&
	     !WILL_FIRE_RL_action_l98c33 &&
	     weightBRAM_serverAdapter_outData_enqData$whas ;
  assign weightBRAM_serverAdapter_outDataCore$DEQ =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_outData_enqAndDeq ||
	     weightBRAM_serverAdapter_outDataCore$EMPTY_N &&
	     WILL_FIRE_RL_action_l98c33 &&
	     !weightBRAM_serverAdapter_outData_enqData$whas ;
  assign weightBRAM_serverAdapter_outDataCore$CLR = 1'b0 ;

  // remaining internal signals
  assign NOT_feature2_23_EQ_feature_91_24___d225 = feature2 != feature ;
  assign NOT_weight2_41_EQ_weight_43_50___d251 = weight2 != weight ;
  assign ab__h1487 =
	     WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ?
	       2'd0 :
	       2'd2 ;
  assign abort_whas__22_AND_abort_wget__23_24_OR_state__ETC___d274 =
	     (state_mkFSMstate == 5'd0 ||
	      !i_54_ULT_8___d155 && state_mkFSMstate == 5'd1 ||
	      !i_54_ULT_8___d155 && state_mkFSMstate == 5'd17) &&
	     (!start_reg_1 || state_fired) ;
  assign featureBRAM_serverAdapter_cnt_6_PLUS_IF_featur_ETC___d32 =
	     featureBRAM_serverAdapter_cnt +
	     (featureBRAM_serverAdapter_cnt_1$whas ? 3'd1 : 3'd0) +
	     (WILL_FIRE_RL_action_l98c33 ? 3'd7 : 3'd0) ;
  assign featureBRAM_serverAdapter_cnt_6_SLT_3___d194 =
	     (featureBRAM_serverAdapter_cnt ^ 3'h4) < 3'd7 ;
  assign ftmp__h47927 = { feature[15:8], uart$rx } ;
  assign i_54_ULT_8___d155 = i < 32'd8 ;
  assign v__h49315 =
	     featureBRAM_serverAdapter_outDataCore$EMPTY_N ?
	       featureBRAM_serverAdapter_outDataCore$D_OUT :
	       featureBRAM_memory$DO ;
  assign v__h49403 =
	     weightBRAM_serverAdapter_outDataCore$EMPTY_N ?
	       weightBRAM_serverAdapter_outDataCore$D_OUT :
	       weightBRAM_memory$DO ;
  assign weightBRAM_serverAdapter_cnt_5_PLUS_IF_weightB_ETC___d91 =
	     weightBRAM_serverAdapter_cnt +
	     (WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ?
		3'd1 :
		3'd0) +
	     (WILL_FIRE_RL_action_l98c33 ? 3'd7 : 3'd0) ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        feature <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	feature2 <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	featureBRAM_serverAdapter_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	featureBRAM_serverAdapter_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	featureRAM_error_r <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fptr_r <= `BSV_ASSIGNMENT_DELAY 11'd0;
	fptr_w <= `BSV_ASSIGNMENT_DELAY 11'd0;
	jj_1_delay_count <= `BSV_ASSIGNMENT_DELAY 7'd0;
	jj_delay_count <= `BSV_ASSIGNMENT_DELAY 10'd1;
	running <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 5'd0;
	weight <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	weight2 <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	weightBRAM_serverAdapter_cnt <= `BSV_ASSIGNMENT_DELAY 3'd0;
	weightBRAM_serverAdapter_s1 <= `BSV_ASSIGNMENT_DELAY 2'd0;
	weightRAM_error_r <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wptr_r <= `BSV_ASSIGNMENT_DELAY 11'd0;
	wptr_w <= `BSV_ASSIGNMENT_DELAY 11'd0;
      end
    else
      begin
        if (feature$EN) feature <= `BSV_ASSIGNMENT_DELAY feature$D_IN;
	if (feature2$EN) feature2 <= `BSV_ASSIGNMENT_DELAY feature2$D_IN;
	if (featureBRAM_serverAdapter_cnt$EN)
	  featureBRAM_serverAdapter_cnt <= `BSV_ASSIGNMENT_DELAY
	      featureBRAM_serverAdapter_cnt$D_IN;
	if (featureBRAM_serverAdapter_s1$EN)
	  featureBRAM_serverAdapter_s1 <= `BSV_ASSIGNMENT_DELAY
	      featureBRAM_serverAdapter_s1$D_IN;
	if (featureRAM_error_r$EN)
	  featureRAM_error_r <= `BSV_ASSIGNMENT_DELAY featureRAM_error_r$D_IN;
	if (fptr_r$EN) fptr_r <= `BSV_ASSIGNMENT_DELAY fptr_r$D_IN;
	if (fptr_w$EN) fptr_w <= `BSV_ASSIGNMENT_DELAY fptr_w$D_IN;
	if (jj_1_delay_count$EN)
	  jj_1_delay_count <= `BSV_ASSIGNMENT_DELAY jj_1_delay_count$D_IN;
	if (jj_delay_count$EN)
	  jj_delay_count <= `BSV_ASSIGNMENT_DELAY jj_delay_count$D_IN;
	if (running$EN) running <= `BSV_ASSIGNMENT_DELAY running$D_IN;
	if (start_reg$EN) start_reg <= `BSV_ASSIGNMENT_DELAY start_reg$D_IN;
	if (start_reg_1$EN)
	  start_reg_1 <= `BSV_ASSIGNMENT_DELAY start_reg_1$D_IN;
	if (state_can_overlap$EN)
	  state_can_overlap <= `BSV_ASSIGNMENT_DELAY state_can_overlap$D_IN;
	if (state_fired$EN)
	  state_fired <= `BSV_ASSIGNMENT_DELAY state_fired$D_IN;
	if (state_mkFSMstate$EN)
	  state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY state_mkFSMstate$D_IN;
	if (weight$EN) weight <= `BSV_ASSIGNMENT_DELAY weight$D_IN;
	if (weight2$EN) weight2 <= `BSV_ASSIGNMENT_DELAY weight2$D_IN;
	if (weightBRAM_serverAdapter_cnt$EN)
	  weightBRAM_serverAdapter_cnt <= `BSV_ASSIGNMENT_DELAY
	      weightBRAM_serverAdapter_cnt$D_IN;
	if (weightBRAM_serverAdapter_s1$EN)
	  weightBRAM_serverAdapter_s1 <= `BSV_ASSIGNMENT_DELAY
	      weightBRAM_serverAdapter_s1$D_IN;
	if (weightRAM_error_r$EN)
	  weightRAM_error_r <= `BSV_ASSIGNMENT_DELAY weightRAM_error_r$D_IN;
	if (wptr_r$EN) wptr_r <= `BSV_ASSIGNMENT_DELAY wptr_r$D_IN;
	if (wptr_w$EN) wptr_w <= `BSV_ASSIGNMENT_DELAY wptr_w$D_IN;
      end
    if (i$EN) i <= `BSV_ASSIGNMENT_DELAY i$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    feature = 16'hAAAA;
    feature2 = 16'hAAAA;
    featureBRAM_serverAdapter_cnt = 3'h2;
    featureBRAM_serverAdapter_s1 = 2'h2;
    featureRAM_error_r = 1'h0;
    fptr_r = 11'h2AA;
    fptr_w = 11'h2AA;
    i = 32'hAAAAAAAA;
    jj_1_delay_count = 7'h2A;
    jj_delay_count = 10'h2AA;
    running = 1'h0;
    start_reg = 1'h0;
    start_reg_1 = 1'h0;
    state_can_overlap = 1'h0;
    state_fired = 1'h0;
    state_mkFSMstate = 5'h0A;
    weight = 16'hAAAA;
    weight2 = 16'hAAAA;
    weightBRAM_serverAdapter_cnt = 3'h2;
    weightBRAM_serverAdapter_s1 = 2'h2;
    weightRAM_error_r = 1'h0;
    wptr_r = 11'h2AA;
    wptr_w = 11'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l77c33) $display("DUT iter %d", i);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l82c33)
	begin
	  v__h47941 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l82c33)
	$write(v__h47941, "     %m.", "DUT uart received feature", "\t");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l82c33) $write("'h%h", ftmp__h47927);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l82c33) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (state_mkFSMstate == 5'd9 && NOT_feature2_23_EQ_feature_91_24___d225)
	$display("DUT mismatch in features (RAM ERROR)");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l116c33)
	begin
	  v__h50864 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l116c33)
	$write(v__h50864, "     %m.", "DUT uart transmitted feature2", "\t");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l116c33) $write("'h%h", feature2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l116c33) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l125c33)
	begin
	  v__h51796 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l125c33)
	$write(v__h51796, "     %m.", "DUT uart transmitted weight2", "\t");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l125c33) $write("'h%h", weight2);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l125c33) $write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l125c33 &&
	  NOT_weight2_41_EQ_weight_43_50___d251)
	$display("DUT mismatch in weights (RAM ERROR)");
    if (RST_N != `BSV_RESET_VALUE)
      if (state_mkFSMstate == 5'd9 &&
	  (WILL_FIRE_RL_action_l113c33 || WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 106, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l106c33] and\n  [RL_action_l113c33, RL_action_l116c33, RL_action_l121c33, RL_action_l125c33,\n  RL_action_d_init_np_1, RL_action_np_1, RL_action_f_update_l74c25] ) fired in\n  the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l113c33 &&
	  (WILL_FIRE_RL_action_l116c33 || WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 113, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l113c33] and\n  [RL_action_l116c33, RL_action_l121c33, RL_action_l125c33,\n  RL_action_d_init_np_1, RL_action_np_1, RL_action_f_update_l74c25] ) fired in\n  the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l116c33 &&
	  (WILL_FIRE_RL_action_l121c33 || WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 116, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l116c33] and\n  [RL_action_l121c33, RL_action_l125c33, RL_action_d_init_np_1,\n  RL_action_np_1, RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l121c33 &&
	  (WILL_FIRE_RL_action_l125c33 || state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 121, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l121c33] and\n  [RL_action_l125c33, RL_action_d_init_np_1, RL_action_np_1,\n  RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l125c33 &&
	  (state_mkFSMstate == 5'd14 || WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 125, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l125c33] and\n  [RL_action_d_init_np_1, RL_action_np_1, RL_action_f_update_l74c25] ) fired\n  in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (state_mkFSMstate == 5'd14 &&
	  (WILL_FIRE_RL_action_np_1 || WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"StmtFSM.bs\", line 41, column 0: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_d_init_np_1] and\n  [RL_action_np_1, RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_np_1 && WILL_FIRE_RL_action_f_update_l74c25)
	$display("Error: \"StmtFSM.bs\", line 41, column 0: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_np_1] and\n  [RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (running &&
	  abort_whas__22_AND_abort_wget__23_24_OR_state__ETC___d274 &&
	  !start_reg)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (featureBRAM_serverAdapter_s1[1] &&
	  !featureBRAM_serverAdapter_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N != `BSV_RESET_VALUE)
      if (weightBRAM_serverAdapter_s1[1] &&
	  !weightBRAM_serverAdapter_outDataCore$FULL_N)
	$display("ERROR: %m: mkBRAMSeverAdapter overrun");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l98c33)
	$display("DUT feature BRAM [%d - 1] = %h", fptr_r, v__h49315);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l98c33)
	$display("DUT weight BRAM [%d - 1] = %h", wptr_r, v__h49403);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_f_init_l74c25 &&
	  (WILL_FIRE_RL_action_d_init_np || WILL_FIRE_RL_action_np ||
	   WILL_FIRE_RL_action_l77c33 ||
	   WILL_FIRE_RL_action_l78c33 ||
	   WILL_FIRE_RL_action_l82c33 ||
	   WILL_FIRE_RL_action_l88c33 ||
	   WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	   WILL_FIRE_RL_action_l98c33 ||
	   state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 74, column 31: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_f_init_l74c25] and\n  [RL_action_d_init_np, RL_action_np, RL_action_l77c33, RL_action_l78c33,\n  RL_action_l82c33, RL_action_l88c33, RL_action_l92c33, RL_action_l98c33,\n  RL_action_l106c33, RL_action_l113c33, RL_action_l116c33, RL_action_l121c33,\n  RL_action_l125c33, RL_action_d_init_np_1, RL_action_np_1,\n  RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_d_init_np &&
	  (WILL_FIRE_RL_action_np || WILL_FIRE_RL_action_l77c33 ||
	   WILL_FIRE_RL_action_l78c33 ||
	   WILL_FIRE_RL_action_l82c33 ||
	   WILL_FIRE_RL_action_l88c33 ||
	   WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	   WILL_FIRE_RL_action_l98c33 ||
	   state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"StmtFSM.bs\", line 41, column 0: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_d_init_np] and\n  [RL_action_np, RL_action_l77c33, RL_action_l78c33, RL_action_l82c33,\n  RL_action_l88c33, RL_action_l92c33, RL_action_l98c33, RL_action_l106c33,\n  RL_action_l113c33, RL_action_l116c33, RL_action_l121c33, RL_action_l125c33,\n  RL_action_d_init_np_1, RL_action_np_1, RL_action_f_update_l74c25] ) fired in\n  the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_np &&
	  (WILL_FIRE_RL_action_l77c33 || WILL_FIRE_RL_action_l78c33 ||
	   WILL_FIRE_RL_action_l82c33 ||
	   WILL_FIRE_RL_action_l88c33 ||
	   WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	   WILL_FIRE_RL_action_l98c33 ||
	   state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"StmtFSM.bs\", line 41, column 0: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_np] and\n  [RL_action_l77c33, RL_action_l78c33, RL_action_l82c33, RL_action_l88c33,\n  RL_action_l92c33, RL_action_l98c33, RL_action_l106c33, RL_action_l113c33,\n  RL_action_l116c33, RL_action_l121c33, RL_action_l125c33,\n  RL_action_d_init_np_1, RL_action_np_1, RL_action_f_update_l74c25] ) fired in\n  the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l77c33 &&
	  (WILL_FIRE_RL_action_l78c33 || WILL_FIRE_RL_action_l82c33 ||
	   WILL_FIRE_RL_action_l88c33 ||
	   WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	   WILL_FIRE_RL_action_l98c33 ||
	   state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 77, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l77c33] and\n  [RL_action_l78c33, RL_action_l82c33, RL_action_l88c33, RL_action_l92c33,\n  RL_action_l98c33, RL_action_l106c33, RL_action_l113c33, RL_action_l116c33,\n  RL_action_l121c33, RL_action_l125c33, RL_action_d_init_np_1, RL_action_np_1,\n  RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l78c33 &&
	  (WILL_FIRE_RL_action_l82c33 || WILL_FIRE_RL_action_l88c33 ||
	   WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	   WILL_FIRE_RL_action_l98c33 ||
	   state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 78, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l78c33] and\n  [RL_action_l82c33, RL_action_l88c33, RL_action_l92c33, RL_action_l98c33,\n  RL_action_l106c33, RL_action_l113c33, RL_action_l116c33, RL_action_l121c33,\n  RL_action_l125c33, RL_action_d_init_np_1, RL_action_np_1,\n  RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l82c33 &&
	  (WILL_FIRE_RL_action_l88c33 ||
	   WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	   WILL_FIRE_RL_action_l98c33 ||
	   state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 82, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l82c33] and\n  [RL_action_l88c33, RL_action_l92c33, RL_action_l98c33, RL_action_l106c33,\n  RL_action_l113c33, RL_action_l116c33, RL_action_l121c33, RL_action_l125c33,\n  RL_action_d_init_np_1, RL_action_np_1, RL_action_f_update_l74c25] ) fired in\n  the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l88c33 &&
	  (WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways ||
	   WILL_FIRE_RL_action_l98c33 ||
	   state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 88, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l88c33] and\n  [RL_action_l92c33, RL_action_l98c33, RL_action_l106c33, RL_action_l113c33,\n  RL_action_l116c33, RL_action_l121c33, RL_action_l125c33,\n  RL_action_d_init_np_1, RL_action_np_1, RL_action_f_update_l74c25] ) fired in\n  the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_action_l98c33 &&
	  (state_mkFSMstate == 5'd9 || WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 98, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l98c33] and\n  [RL_action_l106c33, RL_action_l113c33, RL_action_l116c33, RL_action_l121c33,\n  RL_action_l125c33, RL_action_d_init_np_1, RL_action_np_1,\n  RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_weightBRAM_serverAdapter_stageReadResponseAlways &&
	  (WILL_FIRE_RL_action_l98c33 || state_mkFSMstate == 5'd9 ||
	   WILL_FIRE_RL_action_l113c33 ||
	   WILL_FIRE_RL_action_l116c33 ||
	   WILL_FIRE_RL_action_l121c33 ||
	   WILL_FIRE_RL_action_l125c33 ||
	   state_mkFSMstate == 5'd14 ||
	   WILL_FIRE_RL_action_np_1 ||
	   WILL_FIRE_RL_action_f_update_l74c25))
	$display("Error: \"BRAMUARTTest.bsv\", line 92, column 33: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_action_l92c33] and\n  [RL_action_l98c33, RL_action_l106c33, RL_action_l113c33, RL_action_l116c33,\n  RL_action_l121c33, RL_action_l125c33, RL_action_d_init_np_1, RL_action_np_1,\n  RL_action_f_update_l74c25] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkBRAMUARTTest

