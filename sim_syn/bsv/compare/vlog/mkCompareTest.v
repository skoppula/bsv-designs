//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Sat Dec  9 17:18:23 EST 2017
//
//
// Ports:
// Name                         I/O  size props
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCompareTest;


  // register fin_fcount
  reg [31 : 0] fin_fcount;
  wire [31 : 0] fin_fcount_D_IN;
  wire fin_fcount_EN;

  // register stimulus_init
  reg stimulus_init;
  wire stimulus_init_D_IN, stimulus_init_EN;

  // register stimulus_rand_inp1_initialized
  reg stimulus_rand_inp1_initialized;
  wire stimulus_rand_inp1_initialized_D_IN, stimulus_rand_inp1_initialized_EN;

  // register stimulus_rand_inp2_initialized
  reg stimulus_rand_inp2_initialized;
  wire stimulus_rand_inp2_initialized_D_IN, stimulus_rand_inp2_initialized_EN;

  // ports of submodule clk
  wire clk_CLK_OUT;

  // ports of submodule dut
  wire [63 : 0] dut_request_put;
  wire [31 : 0] dut_response_get;
  wire dut_EN_request_put,
       dut_EN_response_get,
       dut_RDY_request_put,
       dut_RDY_response_get;

  // ports of submodule rstn
  wire rstn_OUT_RST;

  // ports of submodule stimulus_a
  wire [31 : 0] stimulus_a_D_IN;
  wire stimulus_a_CLR,
       stimulus_a_DEQ,
       stimulus_a_EMPTY_N,
       stimulus_a_ENQ,
       stimulus_a_FULL_N;

  // ports of submodule stimulus_b
  wire [31 : 0] stimulus_b_D_IN;
  wire stimulus_b_CLR,
       stimulus_b_DEQ,
       stimulus_b_EMPTY_N,
       stimulus_b_ENQ,
       stimulus_b_FULL_N;

  // ports of submodule stimulus_golden_answer
  wire [31 : 0] stimulus_golden_answer_D_IN, stimulus_golden_answer_D_OUT;
  wire stimulus_golden_answer_CLR,
       stimulus_golden_answer_DEQ,
       stimulus_golden_answer_EMPTY_N,
       stimulus_golden_answer_ENQ,
       stimulus_golden_answer_FULL_N;

  // ports of submodule stimulus_rand_inp1
  wire [27 : 0] stimulus_rand_inp1_OUT;
  wire stimulus_rand_inp1_EN;

  // ports of submodule stimulus_rand_inp2
  wire [27 : 0] stimulus_rand_inp2_OUT;
  wire stimulus_rand_inp2_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_ClientServerRequest,
       CAN_FIRE_RL_ClientServerResponse,
       CAN_FIRE_RL_fin_fin,
       CAN_FIRE_RL_stimulus_do_init,
       CAN_FIRE_RL_stimulus_rand_inp1_every,
       CAN_FIRE_RL_stimulus_rand_inp2_every,
       WILL_FIRE_RL_ClientServerRequest,
       WILL_FIRE_RL_ClientServerResponse,
       WILL_FIRE_RL_fin_fin,
       WILL_FIRE_RL_stimulus_do_init,
       WILL_FIRE_RL_stimulus_rand_inp1_every,
       WILL_FIRE_RL_stimulus_rand_inp2_every;

  // remaining internal signals
  wire [27 : 0] stimulus_rand_inp1_next_REM_127___d18,
		stimulus_rand_inp1_next_REM_129___d20,
		stimulus_rand_inp1_next_REM_255___d22,
		stimulus_rand_inp1_next_REM_257___d24,
		stimulus_rand_inp2_next_REM_127___d28,
		stimulus_rand_inp2_next_REM_129___d30,
		stimulus_rand_inp2_next_REM_255___d32,
		stimulus_rand_inp2_next_REM_257___d34;

  // submodule clk
  ClockGen #(.v1Width(32'd3200),
	     .v2Width(32'd3200),
	     .initDelay(32'd0),
	     .initValue(32'd0),
	     .otherValue(32'd1)) clk(.CLK_OUT(clk_CLK_OUT));

  // submodule dut
  mkCompareRNS dut(.CLK(clk_CLK_OUT),
		   .RST_N(rstn_OUT_RST),
		   .request_put(dut_request_put),
		   .EN_request_put(dut_EN_request_put),
		   .EN_response_get(dut_EN_response_get),
		   .RDY_request_put(dut_RDY_request_put),
		   .response_get(dut_response_get),
		   .RDY_response_get(dut_RDY_response_get));

  // submodule rstn
  InitialReset #(.RSTHOLD(32'd2)) rstn(.CLK(clk_CLK_OUT),
				       .OUT_RST(rstn_OUT_RST));

  // submodule stimulus_a
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) stimulus_a(.RST(rstn_OUT_RST),
					  .CLK(clk_CLK_OUT),
					  .D_IN(stimulus_a_D_IN),
					  .ENQ(stimulus_a_ENQ),
					  .DEQ(stimulus_a_DEQ),
					  .CLR(stimulus_a_CLR),
					  .D_OUT(),
					  .FULL_N(stimulus_a_FULL_N),
					  .EMPTY_N(stimulus_a_EMPTY_N));

  // submodule stimulus_b
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) stimulus_b(.RST(rstn_OUT_RST),
					  .CLK(clk_CLK_OUT),
					  .D_IN(stimulus_b_D_IN),
					  .ENQ(stimulus_b_ENQ),
					  .DEQ(stimulus_b_DEQ),
					  .CLR(stimulus_b_CLR),
					  .D_OUT(),
					  .FULL_N(stimulus_b_FULL_N),
					  .EMPTY_N(stimulus_b_EMPTY_N));

  // submodule stimulus_golden_answer
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) stimulus_golden_answer(.RST(rstn_OUT_RST),
						      .CLK(clk_CLK_OUT),
						      .D_IN(stimulus_golden_answer_D_IN),
						      .ENQ(stimulus_golden_answer_ENQ),
						      .DEQ(stimulus_golden_answer_DEQ),
						      .CLR(stimulus_golden_answer_CLR),
						      .D_OUT(stimulus_golden_answer_D_OUT),
						      .FULL_N(stimulus_golden_answer_FULL_N),
						      .EMPTY_N(stimulus_golden_answer_EMPTY_N));

  // submodule stimulus_rand_inp1
  ConstrainedRandom #(.width(32'd28),
		      .min(28'h0),
		      .max(28'd268435455)) stimulus_rand_inp1(.RST(rstn_OUT_RST),
							      .CLK(clk_CLK_OUT),
							      .EN(stimulus_rand_inp1_EN),
							      .OUT(stimulus_rand_inp1_OUT));

  // submodule stimulus_rand_inp2
  ConstrainedRandom #(.width(32'd28),
		      .min(28'h0),
		      .max(28'd268435455)) stimulus_rand_inp2(.RST(rstn_OUT_RST),
							      .CLK(clk_CLK_OUT),
							      .EN(stimulus_rand_inp2_EN),
							      .OUT(stimulus_rand_inp2_OUT));

  // rule RL_ClientServerResponse
  assign CAN_FIRE_RL_ClientServerResponse =
	     dut_RDY_response_get && stimulus_golden_answer_EMPTY_N &&
	     stimulus_a_EMPTY_N &&
	     stimulus_b_EMPTY_N ;
  assign WILL_FIRE_RL_ClientServerResponse =
	     CAN_FIRE_RL_ClientServerResponse ;

  // rule RL_ClientServerRequest
  assign CAN_FIRE_RL_ClientServerRequest =
	     dut_RDY_request_put && stimulus_rand_inp1_initialized &&
	     stimulus_rand_inp2_initialized &&
	     stimulus_a_FULL_N &&
	     stimulus_b_FULL_N &&
	     stimulus_golden_answer_FULL_N ;
  assign WILL_FIRE_RL_ClientServerRequest = CAN_FIRE_RL_ClientServerRequest ;

  // rule RL_stimulus_rand_inp1_every
  assign CAN_FIRE_RL_stimulus_rand_inp1_every =
	     !stimulus_rand_inp1_initialized ;
  assign WILL_FIRE_RL_stimulus_rand_inp1_every =
	     CAN_FIRE_RL_stimulus_rand_inp1_every ;

  // rule RL_stimulus_rand_inp2_every
  assign CAN_FIRE_RL_stimulus_rand_inp2_every =
	     !stimulus_rand_inp2_initialized ;
  assign WILL_FIRE_RL_stimulus_rand_inp2_every =
	     CAN_FIRE_RL_stimulus_rand_inp2_every ;

  // rule RL_stimulus_do_init
  assign CAN_FIRE_RL_stimulus_do_init = !stimulus_init ;
  assign WILL_FIRE_RL_stimulus_do_init = CAN_FIRE_RL_stimulus_do_init ;

  // rule RL_fin_fin
  assign CAN_FIRE_RL_fin_fin = 1'd1 ;
  assign WILL_FIRE_RL_fin_fin = 1'd1 ;

  // register fin_fcount
  assign fin_fcount_D_IN = fin_fcount + 32'd1 ;
  assign fin_fcount_EN = 1'd1 ;

  // register stimulus_init
  assign stimulus_init_D_IN = 1'd1 ;
  assign stimulus_init_EN = CAN_FIRE_RL_stimulus_do_init ;

  // register stimulus_rand_inp1_initialized
  assign stimulus_rand_inp1_initialized_D_IN = 1'd1 ;
  assign stimulus_rand_inp1_initialized_EN = CAN_FIRE_RL_stimulus_do_init ;

  // register stimulus_rand_inp2_initialized
  assign stimulus_rand_inp2_initialized_D_IN = 1'd1 ;
  assign stimulus_rand_inp2_initialized_EN = CAN_FIRE_RL_stimulus_do_init ;

  // submodule dut
  assign dut_request_put =
	     { stimulus_rand_inp1_next_REM_127___d18[6:0],
	       stimulus_rand_inp1_next_REM_129___d20[7:0],
	       stimulus_rand_inp1_next_REM_255___d22[7:0],
	       stimulus_rand_inp1_next_REM_257___d24[8:0],
	       stimulus_rand_inp2_next_REM_127___d28[6:0],
	       stimulus_rand_inp2_next_REM_129___d30[7:0],
	       stimulus_rand_inp2_next_REM_255___d32[7:0],
	       stimulus_rand_inp2_next_REM_257___d34[8:0] } ;
  assign dut_EN_request_put = CAN_FIRE_RL_ClientServerRequest ;
  assign dut_EN_response_get = CAN_FIRE_RL_ClientServerResponse ;

  // submodule stimulus_a
  assign stimulus_a_D_IN =
	     { stimulus_rand_inp1_next_REM_127___d18[6:0],
	       stimulus_rand_inp1_next_REM_129___d20[7:0],
	       stimulus_rand_inp1_next_REM_255___d22[7:0],
	       stimulus_rand_inp1_next_REM_257___d24[8:0] } ;
  assign stimulus_a_ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign stimulus_a_DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign stimulus_a_CLR = 1'b0 ;

  // submodule stimulus_b
  assign stimulus_b_D_IN =
	     { stimulus_rand_inp2_next_REM_127___d28[6:0],
	       stimulus_rand_inp2_next_REM_129___d30[7:0],
	       stimulus_rand_inp2_next_REM_255___d32[7:0],
	       stimulus_rand_inp2_next_REM_257___d34[8:0] } ;
  assign stimulus_b_ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign stimulus_b_DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign stimulus_b_CLR = 1'b0 ;

  // submodule stimulus_golden_answer
  assign stimulus_golden_answer_D_IN =
	     (stimulus_rand_inp1_OUT < stimulus_rand_inp2_OUT) ?
	       { stimulus_rand_inp2_next_REM_127___d28[6:0],
		 stimulus_rand_inp2_next_REM_129___d30[7:0],
		 stimulus_rand_inp2_next_REM_255___d32[7:0],
		 stimulus_rand_inp2_next_REM_257___d34[8:0] } :
	       { stimulus_rand_inp1_next_REM_127___d18[6:0],
		 stimulus_rand_inp1_next_REM_129___d20[7:0],
		 stimulus_rand_inp1_next_REM_255___d22[7:0],
		 stimulus_rand_inp1_next_REM_257___d24[8:0] } ;
  assign stimulus_golden_answer_ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign stimulus_golden_answer_DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign stimulus_golden_answer_CLR = 1'b0 ;

  // submodule stimulus_rand_inp1
  assign stimulus_rand_inp1_EN =
	     WILL_FIRE_RL_ClientServerRequest ||
	     WILL_FIRE_RL_stimulus_rand_inp1_every ;

  // submodule stimulus_rand_inp2
  assign stimulus_rand_inp2_EN =
	     WILL_FIRE_RL_ClientServerRequest ||
	     WILL_FIRE_RL_stimulus_rand_inp2_every ;

  // remaining internal signals
  assign stimulus_rand_inp1_next_REM_127___d18 =
	     stimulus_rand_inp1_OUT % 28'd127 ;
  assign stimulus_rand_inp1_next_REM_129___d20 =
	     stimulus_rand_inp1_OUT % 28'd129 ;
  assign stimulus_rand_inp1_next_REM_255___d22 =
	     stimulus_rand_inp1_OUT % 28'd255 ;
  assign stimulus_rand_inp1_next_REM_257___d24 =
	     stimulus_rand_inp1_OUT % 28'd257 ;
  assign stimulus_rand_inp2_next_REM_127___d28 =
	     stimulus_rand_inp2_OUT % 28'd127 ;
  assign stimulus_rand_inp2_next_REM_129___d30 =
	     stimulus_rand_inp2_OUT % 28'd129 ;
  assign stimulus_rand_inp2_next_REM_255___d32 =
	     stimulus_rand_inp2_OUT % 28'd255 ;
  assign stimulus_rand_inp2_next_REM_257___d34 =
	     stimulus_rand_inp2_OUT % 28'd257 ;

  // handling of inlined registers

  always@(posedge clk_CLK_OUT)
  begin
    if (rstn_OUT_RST == `BSV_RESET_VALUE)
      begin
        fin_fcount <= `BSV_ASSIGNMENT_DELAY 32'd0;
	stimulus_init <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stimulus_rand_inp1_initialized <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stimulus_rand_inp2_initialized <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (fin_fcount_EN)
	  fin_fcount <= `BSV_ASSIGNMENT_DELAY fin_fcount_D_IN;
	if (stimulus_init_EN)
	  stimulus_init <= `BSV_ASSIGNMENT_DELAY stimulus_init_D_IN;
	if (stimulus_rand_inp1_initialized_EN)
	  stimulus_rand_inp1_initialized <= `BSV_ASSIGNMENT_DELAY
	      stimulus_rand_inp1_initialized_D_IN;
	if (stimulus_rand_inp2_initialized_EN)
	  stimulus_rand_inp2_initialized <= `BSV_ASSIGNMENT_DELAY
	      stimulus_rand_inp2_initialized_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fin_fcount = 32'hAAAAAAAA;
    stimulus_init = 1'h0;
    stimulus_rand_inp1_initialized = 1'h0;
    stimulus_rand_inp2_initialized = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge clk_CLK_OUT)
  begin
    #0;
    if (rstn_OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_ClientServerResponse &&
	  (stimulus_golden_answer_D_OUT[31:25] != dut_response_get[31:25] ||
	   stimulus_golden_answer_D_OUT[24:17] != dut_response_get[24:17] ||
	   stimulus_golden_answer_D_OUT[16:9] != dut_response_get[16:9] ||
	   stimulus_golden_answer_D_OUT[8:0] != dut_response_get[8:0]))
	$display("FAIL comparison");
    if (rstn_OUT_RST != `BSV_RESET_VALUE)
      if (fin_fcount == 32'd1000) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkCompareTest

