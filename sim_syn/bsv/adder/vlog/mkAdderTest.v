//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Fri Dec  8 19:09:16 EST 2017
//
//
// Ports:
// Name                         I/O  size props
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAdderTest;


  // register fin_fcount
  reg [31 : 0] fin_fcount;
  wire [31 : 0] fin_fcount_D_IN;
  wire fin_fcount_EN;

  // register stimulus_init
  reg stimulus_init;
  wire stimulus_init_D_IN, stimulus_init_EN;

  // register stimulus_rnd_a_initialized
  reg stimulus_rnd_a_initialized;
  wire stimulus_rnd_a_initialized_D_IN, stimulus_rnd_a_initialized_EN;

  // register stimulus_rnd_b_initialized
  reg stimulus_rnd_b_initialized;
  wire stimulus_rnd_b_initialized_D_IN, stimulus_rnd_b_initialized_EN;

  // ports of submodule clk
  wire clk_CLK_OUT;

  // ports of submodule dut
  wire [63 : 0] dut_request_put;
  wire [31 : 0] dut_response_get;
  wire dut_EN_request_put,
       dut_EN_response_get,
       dut_RDY_request_put,
       dut_RDY_response_get;

  // ports of submodule rstn
  wire rstn_OUT_RST;

  // ports of submodule stimulus_a
  wire [31 : 0] stimulus_a_D_IN, stimulus_a_D_OUT;
  wire stimulus_a_CLR,
       stimulus_a_DEQ,
       stimulus_a_EMPTY_N,
       stimulus_a_ENQ,
       stimulus_a_FULL_N;

  // ports of submodule stimulus_b
  wire [31 : 0] stimulus_b_D_IN, stimulus_b_D_OUT;
  wire stimulus_b_CLR,
       stimulus_b_DEQ,
       stimulus_b_EMPTY_N,
       stimulus_b_ENQ,
       stimulus_b_FULL_N;

  // ports of submodule stimulus_rnd_a
  wire [31 : 0] stimulus_rnd_a_OUT;
  wire stimulus_rnd_a_EN;

  // ports of submodule stimulus_rnd_b
  wire [31 : 0] stimulus_rnd_b_OUT;
  wire stimulus_rnd_b_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_ClientServerRequest,
       CAN_FIRE_RL_ClientServerResponse,
       CAN_FIRE_RL_fin_fin,
       CAN_FIRE_RL_stimulus_do_init,
       CAN_FIRE_RL_stimulus_rnd_a_every,
       CAN_FIRE_RL_stimulus_rnd_b_every,
       WILL_FIRE_RL_ClientServerRequest,
       WILL_FIRE_RL_ClientServerResponse,
       WILL_FIRE_RL_fin_fin,
       WILL_FIRE_RL_stimulus_do_init,
       WILL_FIRE_RL_stimulus_rnd_a_every,
       WILL_FIRE_RL_stimulus_rnd_b_every;

  // remaining internal signals
  wire [31 : 0] stimulus_a_first__2_PLUS_stimulus_b_first__3___d24;

  // submodule clk
  ClockGen #(.v1Width(32'd800),
	     .v2Width(32'd800),
	     .initDelay(32'd0),
	     .initValue(32'd0),
	     .otherValue(32'd1)) clk(.CLK_OUT(clk_CLK_OUT));

  // submodule dut
  mkAdder32 dut(.CLK(clk_CLK_OUT),
		.RST_N(rstn_OUT_RST),
		.request_put(dut_request_put),
		.EN_request_put(dut_EN_request_put),
		.EN_response_get(dut_EN_response_get),
		.RDY_request_put(dut_RDY_request_put),
		.response_get(dut_response_get),
		.RDY_response_get(dut_RDY_response_get));

  // submodule rstn
  InitialReset #(.RSTHOLD(32'd2)) rstn(.CLK(clk_CLK_OUT),
				       .OUT_RST(rstn_OUT_RST));

  // submodule stimulus_a
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) stimulus_a(.RST(rstn_OUT_RST),
					  .CLK(clk_CLK_OUT),
					  .D_IN(stimulus_a_D_IN),
					  .ENQ(stimulus_a_ENQ),
					  .DEQ(stimulus_a_DEQ),
					  .CLR(stimulus_a_CLR),
					  .D_OUT(stimulus_a_D_OUT),
					  .FULL_N(stimulus_a_FULL_N),
					  .EMPTY_N(stimulus_a_EMPTY_N));

  // submodule stimulus_b
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) stimulus_b(.RST(rstn_OUT_RST),
					  .CLK(clk_CLK_OUT),
					  .D_IN(stimulus_b_D_IN),
					  .ENQ(stimulus_b_ENQ),
					  .DEQ(stimulus_b_DEQ),
					  .CLR(stimulus_b_CLR),
					  .D_OUT(stimulus_b_D_OUT),
					  .FULL_N(stimulus_b_FULL_N),
					  .EMPTY_N(stimulus_b_EMPTY_N));

  // submodule stimulus_rnd_a
  ConstrainedRandom #(.width(32'd32),
		      .min(32'h0),
		      .max(32'hFFFFFFFF)) stimulus_rnd_a(.RST(rstn_OUT_RST),
							 .CLK(clk_CLK_OUT),
							 .EN(stimulus_rnd_a_EN),
							 .OUT(stimulus_rnd_a_OUT));

  // submodule stimulus_rnd_b
  ConstrainedRandom #(.width(32'd32),
		      .min(32'h0),
		      .max(32'hFFFFFFFF)) stimulus_rnd_b(.RST(rstn_OUT_RST),
							 .CLK(clk_CLK_OUT),
							 .EN(stimulus_rnd_b_EN),
							 .OUT(stimulus_rnd_b_OUT));

  // rule RL_ClientServerResponse
  assign CAN_FIRE_RL_ClientServerResponse =
	     dut_RDY_response_get && stimulus_a_EMPTY_N &&
	     stimulus_b_EMPTY_N ;
  assign WILL_FIRE_RL_ClientServerResponse =
	     CAN_FIRE_RL_ClientServerResponse ;

  // rule RL_ClientServerRequest
  assign CAN_FIRE_RL_ClientServerRequest =
	     dut_RDY_request_put && stimulus_rnd_a_initialized &&
	     stimulus_rnd_b_initialized &&
	     stimulus_a_FULL_N &&
	     stimulus_b_FULL_N ;
  assign WILL_FIRE_RL_ClientServerRequest = CAN_FIRE_RL_ClientServerRequest ;

  // rule RL_stimulus_rnd_a_every
  assign CAN_FIRE_RL_stimulus_rnd_a_every = !stimulus_rnd_a_initialized ;
  assign WILL_FIRE_RL_stimulus_rnd_a_every =
	     CAN_FIRE_RL_stimulus_rnd_a_every ;

  // rule RL_stimulus_rnd_b_every
  assign CAN_FIRE_RL_stimulus_rnd_b_every = !stimulus_rnd_b_initialized ;
  assign WILL_FIRE_RL_stimulus_rnd_b_every =
	     CAN_FIRE_RL_stimulus_rnd_b_every ;

  // rule RL_stimulus_do_init
  assign CAN_FIRE_RL_stimulus_do_init = !stimulus_init ;
  assign WILL_FIRE_RL_stimulus_do_init = CAN_FIRE_RL_stimulus_do_init ;

  // rule RL_fin_fin
  assign CAN_FIRE_RL_fin_fin = 1'd1 ;
  assign WILL_FIRE_RL_fin_fin = 1'd1 ;

  // register fin_fcount
  assign fin_fcount_D_IN = fin_fcount + 32'd1 ;
  assign fin_fcount_EN = 1'd1 ;

  // register stimulus_init
  assign stimulus_init_D_IN = 1'd1 ;
  assign stimulus_init_EN = CAN_FIRE_RL_stimulus_do_init ;

  // register stimulus_rnd_a_initialized
  assign stimulus_rnd_a_initialized_D_IN = 1'd1 ;
  assign stimulus_rnd_a_initialized_EN = CAN_FIRE_RL_stimulus_do_init ;

  // register stimulus_rnd_b_initialized
  assign stimulus_rnd_b_initialized_D_IN = 1'd1 ;
  assign stimulus_rnd_b_initialized_EN = CAN_FIRE_RL_stimulus_do_init ;

  // submodule dut
  assign dut_request_put = { stimulus_rnd_a_OUT, stimulus_rnd_b_OUT } ;
  assign dut_EN_request_put = CAN_FIRE_RL_ClientServerRequest ;
  assign dut_EN_response_get = CAN_FIRE_RL_ClientServerResponse ;

  // submodule stimulus_a
  assign stimulus_a_D_IN = stimulus_rnd_a_OUT ;
  assign stimulus_a_ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign stimulus_a_DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign stimulus_a_CLR = 1'b0 ;

  // submodule stimulus_b
  assign stimulus_b_D_IN = stimulus_rnd_b_OUT ;
  assign stimulus_b_ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign stimulus_b_DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign stimulus_b_CLR = 1'b0 ;

  // submodule stimulus_rnd_a
  assign stimulus_rnd_a_EN =
	     WILL_FIRE_RL_ClientServerRequest ||
	     WILL_FIRE_RL_stimulus_rnd_a_every ;

  // submodule stimulus_rnd_b
  assign stimulus_rnd_b_EN =
	     WILL_FIRE_RL_ClientServerRequest ||
	     WILL_FIRE_RL_stimulus_rnd_b_every ;

  // remaining internal signals
  assign stimulus_a_first__2_PLUS_stimulus_b_first__3___d24 =
	     stimulus_a_D_OUT + stimulus_b_D_OUT ;

  // handling of inlined registers

  always@(posedge clk_CLK_OUT)
  begin
    if (rstn_OUT_RST == `BSV_RESET_VALUE)
      begin
        fin_fcount <= `BSV_ASSIGNMENT_DELAY 32'd0;
	stimulus_init <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stimulus_rnd_a_initialized <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stimulus_rnd_b_initialized <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (fin_fcount_EN)
	  fin_fcount <= `BSV_ASSIGNMENT_DELAY fin_fcount_D_IN;
	if (stimulus_init_EN)
	  stimulus_init <= `BSV_ASSIGNMENT_DELAY stimulus_init_D_IN;
	if (stimulus_rnd_a_initialized_EN)
	  stimulus_rnd_a_initialized <= `BSV_ASSIGNMENT_DELAY
	      stimulus_rnd_a_initialized_D_IN;
	if (stimulus_rnd_b_initialized_EN)
	  stimulus_rnd_b_initialized <= `BSV_ASSIGNMENT_DELAY
	      stimulus_rnd_b_initialized_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fin_fcount = 32'hAAAAAAAA;
    stimulus_init = 1'h0;
    stimulus_rnd_a_initialized = 1'h0;
    stimulus_rnd_b_initialized = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge clk_CLK_OUT)
  begin
    #0;
    if (rstn_OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_ClientServerResponse &&
	  stimulus_a_first__2_PLUS_stimulus_b_first__3___d24 !=
	  dut_response_get)
	$display("FAIL: out: %d + %d = %d == %d",
		 $unsigned(stimulus_a_D_OUT),
		 $unsigned(stimulus_b_D_OUT),
		 $unsigned(stimulus_a_first__2_PLUS_stimulus_b_first__3___d24),
		 $unsigned(dut_response_get));
    if (rstn_OUT_RST != `BSV_RESET_VALUE)
      if (fin_fcount == 32'd1000) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkAdderTest

