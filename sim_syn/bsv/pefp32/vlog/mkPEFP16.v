//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Mon Dec 11 18:07:12 EST 2017
//
//
// Ports:
// Name                         I/O  size props
// RDY_load_weights               O     1 const
// RDY_add_input                  O     1 const
// RDY_add_constant               O     1 const
// RDY_nonlinearity               O     1 const
// get_partial_sum                O     8
// RDY_get_partial_sum            O     1 const
// read_weights                   O   128 reg
// RDY_read_weights               O     1 const
// is_ready                       O     1
// RDY_is_ready                   O     1 const
// RDY_reset_pe                   O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// load_weights_weights           I   128 reg
// add_input_inp                  I     8
// add_constant_constant          I     8
// EN_load_weights                I     1
// EN_add_input                   I     1
// EN_add_constant                I     1
// EN_nonlinearity                I     1
// EN_reset_pe                    I     1
// EN_get_partial_sum             I     1 unused
// EN_read_weights                I     1 unused
// EN_is_ready                    I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPEFP16(CLK,
		RST_N,

		load_weights_weights,
		EN_load_weights,
		RDY_load_weights,

		add_input_inp,
		EN_add_input,
		RDY_add_input,

		add_constant_constant,
		EN_add_constant,
		RDY_add_constant,

		EN_nonlinearity,
		RDY_nonlinearity,

		EN_get_partial_sum,
		get_partial_sum,
		RDY_get_partial_sum,

		EN_read_weights,
		read_weights,
		RDY_read_weights,

		EN_is_ready,
		is_ready,
		RDY_is_ready,

		EN_reset_pe,
		RDY_reset_pe);
  input  CLK;
  input  RST_N;

  // action method load_weights
  input  [127 : 0] load_weights_weights;
  input  EN_load_weights;
  output RDY_load_weights;

  // action method add_input
  input  [7 : 0] add_input_inp;
  input  EN_add_input;
  output RDY_add_input;

  // action method add_constant
  input  [7 : 0] add_constant_constant;
  input  EN_add_constant;
  output RDY_add_constant;

  // action method nonlinearity
  input  EN_nonlinearity;
  output RDY_nonlinearity;

  // actionvalue method get_partial_sum
  input  EN_get_partial_sum;
  output [7 : 0] get_partial_sum;
  output RDY_get_partial_sum;

  // actionvalue method read_weights
  input  EN_read_weights;
  output [127 : 0] read_weights;
  output RDY_read_weights;

  // actionvalue method is_ready
  input  EN_is_ready;
  output is_ready;
  output RDY_is_ready;

  // action method reset_pe
  input  EN_reset_pe;
  output RDY_reset_pe;

  // signals for module outputs
  wire [127 : 0] read_weights;
  wire [7 : 0] get_partial_sum;
  wire RDY_add_constant,
       RDY_add_input,
       RDY_get_partial_sum,
       RDY_is_ready,
       RDY_load_weights,
       RDY_nonlinearity,
       RDY_read_weights,
       RDY_reset_pe,
       is_ready;

  // register m_partial_sum
  reg [15 : 0] m_partial_sum;
  reg [15 : 0] m_partial_sum_D_IN;
  wire m_partial_sum_EN;

  // register m_step
  reg [3 : 0] m_step;
  wire [3 : 0] m_step_D_IN;
  wire m_step_EN;

  // register m_weight_regs_0
  reg [15 : 0] m_weight_regs_0;
  wire [15 : 0] m_weight_regs_0_D_IN;
  wire m_weight_regs_0_EN;

  // register m_weight_regs_1
  reg [15 : 0] m_weight_regs_1;
  wire [15 : 0] m_weight_regs_1_D_IN;
  wire m_weight_regs_1_EN;

  // register m_weight_regs_2
  reg [15 : 0] m_weight_regs_2;
  wire [15 : 0] m_weight_regs_2_D_IN;
  wire m_weight_regs_2_EN;

  // register m_weight_regs_3
  reg [15 : 0] m_weight_regs_3;
  wire [15 : 0] m_weight_regs_3_D_IN;
  wire m_weight_regs_3_EN;

  // register m_weight_regs_4
  reg [15 : 0] m_weight_regs_4;
  wire [15 : 0] m_weight_regs_4_D_IN;
  wire m_weight_regs_4_EN;

  // register m_weight_regs_5
  reg [15 : 0] m_weight_regs_5;
  wire [15 : 0] m_weight_regs_5_D_IN;
  wire m_weight_regs_5_EN;

  // register m_weight_regs_6
  reg [15 : 0] m_weight_regs_6;
  wire [15 : 0] m_weight_regs_6_D_IN;
  wire m_weight_regs_6_EN;

  // register m_weight_regs_7
  reg [15 : 0] m_weight_regs_7;
  wire [15 : 0] m_weight_regs_7_D_IN;
  wire m_weight_regs_7_EN;

  // rule scheduling signals
  wire CAN_FIRE_add_constant,
       CAN_FIRE_add_input,
       CAN_FIRE_get_partial_sum,
       CAN_FIRE_is_ready,
       CAN_FIRE_load_weights,
       CAN_FIRE_nonlinearity,
       CAN_FIRE_read_weights,
       CAN_FIRE_reset_pe,
       WILL_FIRE_add_constant,
       WILL_FIRE_add_input,
       WILL_FIRE_get_partial_sum,
       WILL_FIRE_is_ready,
       WILL_FIRE_load_weights,
       WILL_FIRE_nonlinearity,
       WILL_FIRE_read_weights,
       WILL_FIRE_reset_pe;

  // inputs to muxes for submodule ports
  wire [15 : 0] MUX_m_partial_sum_write_1__VAL_2,
		MUX_m_partial_sum_write_1__VAL_3,
		MUX_m_partial_sum_write_1__VAL_4;
  wire [3 : 0] MUX_m_step_write_1__VAL_2;

  // remaining internal signals
  reg [7 : 0] weight_se_f__h2891, weight_se_i__h2890;
  wire [31 : 0] IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d58,
		IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d60;
  wire [23 : 0] IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75,
		IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d72;
  wire [15 : 0] IF_NOT_IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BIT_ETC___d92,
		m_partial_sum_PLUS_IF_NOT_IF_NOT_IF_SEL_ARR_m__ETC___d96,
		x__h3006,
		x__h3022,
		x__h3025,
		x__h3041;
  wire [7 : 0] in2_f__h5165,
	       in2_i__h5164,
	       inp_se_f__h2975,
	       inp_se_i__h2974,
	       y_f__h3633;
  wire [1 : 0] add_constant_constant_BITS_7_TO_6__q2,
	       add_input_inp_BITS_7_TO_6__q1;

  // action method load_weights
  assign RDY_load_weights = 1'd1 ;
  assign CAN_FIRE_load_weights = 1'd1 ;
  assign WILL_FIRE_load_weights = EN_load_weights ;

  // action method add_input
  assign RDY_add_input = 1'd1 ;
  assign CAN_FIRE_add_input = 1'd1 ;
  assign WILL_FIRE_add_input = EN_add_input ;

  // action method add_constant
  assign RDY_add_constant = 1'd1 ;
  assign CAN_FIRE_add_constant = 1'd1 ;
  assign WILL_FIRE_add_constant = EN_add_constant ;

  // action method nonlinearity
  assign RDY_nonlinearity = 1'd1 ;
  assign CAN_FIRE_nonlinearity = 1'd1 ;
  assign WILL_FIRE_nonlinearity = EN_nonlinearity ;

  // actionvalue method get_partial_sum
  assign get_partial_sum =
	     (!m_partial_sum[15] &&
	      (m_partial_sum[9] || m_partial_sum[15:10] != 6'd0)) ?
	       8'd127 :
	       ((m_partial_sum[15] &&
		 (!m_partial_sum[9] || ~m_partial_sum[15:10] != 6'd0)) ?
		  8'd128 :
		  m_partial_sum[9:2]) ;
  assign RDY_get_partial_sum = 1'd1 ;
  assign CAN_FIRE_get_partial_sum = 1'd1 ;
  assign WILL_FIRE_get_partial_sum = EN_get_partial_sum ;

  // actionvalue method read_weights
  assign read_weights =
	     { m_weight_regs_7,
	       m_weight_regs_6,
	       m_weight_regs_5,
	       m_weight_regs_4,
	       m_weight_regs_3,
	       m_weight_regs_2,
	       m_weight_regs_1,
	       m_weight_regs_0 } ;
  assign RDY_read_weights = 1'd1 ;
  assign CAN_FIRE_read_weights = 1'd1 ;
  assign WILL_FIRE_read_weights = EN_read_weights ;

  // actionvalue method is_ready
  assign is_ready = m_step == 4'd8 ;
  assign RDY_is_ready = 1'd1 ;
  assign CAN_FIRE_is_ready = 1'd1 ;
  assign WILL_FIRE_is_ready = EN_is_ready ;

  // action method reset_pe
  assign RDY_reset_pe = 1'd1 ;
  assign CAN_FIRE_reset_pe = 1'd1 ;
  assign WILL_FIRE_reset_pe = EN_reset_pe ;

  // inputs to muxes for submodule ports
  assign MUX_m_partial_sum_write_1__VAL_2 =
	     (!m_partial_sum[15] &&
	      !IF_NOT_IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BIT_ETC___d92[15] &&
	      m_partial_sum_PLUS_IF_NOT_IF_NOT_IF_SEL_ARR_m__ETC___d96[15]) ?
	       16'd32767 :
	       ((m_partial_sum[15] &&
		 IF_NOT_IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BIT_ETC___d92[15] &&
		 !m_partial_sum_PLUS_IF_NOT_IF_NOT_IF_SEL_ARR_m__ETC___d96[15]) ?
		  16'd32768 :
		  m_partial_sum_PLUS_IF_NOT_IF_NOT_IF_SEL_ARR_m__ETC___d96) ;
  assign MUX_m_partial_sum_write_1__VAL_3 =
	     m_partial_sum[15] ? 16'd0 : m_partial_sum ;
  assign MUX_m_partial_sum_write_1__VAL_4 =
	     m_partial_sum + { in2_i__h5164, in2_f__h5165 } ;
  assign MUX_m_step_write_1__VAL_2 = m_step + 4'd1 ;

  // register m_partial_sum
  always@(EN_reset_pe or
	  EN_add_input or
	  MUX_m_partial_sum_write_1__VAL_2 or
	  EN_nonlinearity or
	  MUX_m_partial_sum_write_1__VAL_3 or
	  EN_add_constant or MUX_m_partial_sum_write_1__VAL_4)
  case (1'b1)
    EN_reset_pe: m_partial_sum_D_IN = 16'd0;
    EN_add_input: m_partial_sum_D_IN = MUX_m_partial_sum_write_1__VAL_2;
    EN_nonlinearity: m_partial_sum_D_IN = MUX_m_partial_sum_write_1__VAL_3;
    EN_add_constant: m_partial_sum_D_IN = MUX_m_partial_sum_write_1__VAL_4;
    default: m_partial_sum_D_IN =
		 16'b1010101010101010 /* unspecified value */ ;
  endcase
  assign m_partial_sum_EN =
	     EN_add_input || EN_add_constant || EN_nonlinearity ||
	     EN_reset_pe ;

  // register m_step
  assign m_step_D_IN = EN_reset_pe ? 4'd0 : MUX_m_step_write_1__VAL_2 ;
  assign m_step_EN = EN_add_input || EN_reset_pe ;

  // register m_weight_regs_0
  assign m_weight_regs_0_D_IN = load_weights_weights[15:0] ;
  assign m_weight_regs_0_EN = EN_load_weights ;

  // register m_weight_regs_1
  assign m_weight_regs_1_D_IN = load_weights_weights[31:16] ;
  assign m_weight_regs_1_EN = EN_load_weights ;

  // register m_weight_regs_2
  assign m_weight_regs_2_D_IN = load_weights_weights[47:32] ;
  assign m_weight_regs_2_EN = EN_load_weights ;

  // register m_weight_regs_3
  assign m_weight_regs_3_D_IN = load_weights_weights[63:48] ;
  assign m_weight_regs_3_EN = EN_load_weights ;

  // register m_weight_regs_4
  assign m_weight_regs_4_D_IN = load_weights_weights[79:64] ;
  assign m_weight_regs_4_EN = EN_load_weights ;

  // register m_weight_regs_5
  assign m_weight_regs_5_D_IN = load_weights_weights[95:80] ;
  assign m_weight_regs_5_EN = EN_load_weights ;

  // register m_weight_regs_6
  assign m_weight_regs_6_D_IN = load_weights_weights[111:96] ;
  assign m_weight_regs_6_EN = EN_load_weights ;

  // register m_weight_regs_7
  assign m_weight_regs_7_D_IN = load_weights_weights[127:112] ;
  assign m_weight_regs_7_EN = EN_load_weights ;

  // remaining internal signals
  assign IF_NOT_IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BIT_ETC___d92 =
	     (!IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75[23] &&
	      (IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75[15] ||
	       IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75[23:16] !=
	       8'd0)) ?
	       16'd32767 :
	       ((IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75[23] &&
		 (!IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75[15] ||
		  ~IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75[23:16] !=
		  8'd0)) ?
		  16'd32768 :
		  IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75[15:0]) ;
  assign IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_ETC___d75 =
	     (!IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d60[31] &&
	      IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d72[23]) ?
	       24'd8388607 :
	       IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d72 ;
  assign IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d58 =
	     x__h3006 * x__h3025 ;
  assign IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d60 =
	     (weight_se_i__h2890[7] && !inp_se_i__h2974[7] ||
	      inp_se_i__h2974[7] && !weight_se_i__h2890[7]) ?
	       -IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d58 :
	       IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d58 ;
  assign IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d72 =
	     IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d60[31:8] +
	     { 16'd0, y_f__h3633 } ;
  assign add_constant_constant_BITS_7_TO_6__q2 = add_constant_constant[7:6] ;
  assign add_input_inp_BITS_7_TO_6__q1 = add_input_inp[7:6] ;
  assign in2_f__h5165 = { add_constant_constant[5:0], 2'd0 } ;
  assign in2_i__h5164 =
	     { {6{add_constant_constant_BITS_7_TO_6__q2[1]}},
	       add_constant_constant_BITS_7_TO_6__q2 } ;
  assign inp_se_f__h2975 = { add_input_inp[5:0], 2'd0 } ;
  assign inp_se_i__h2974 =
	     { {6{add_input_inp_BITS_7_TO_6__q1[1]}},
	       add_input_inp_BITS_7_TO_6__q1 } ;
  assign m_partial_sum_PLUS_IF_NOT_IF_NOT_IF_SEL_ARR_m__ETC___d96 =
	     m_partial_sum +
	     IF_NOT_IF_NOT_IF_SEL_ARR_m_weight_regs_0_2_BIT_ETC___d92 ;
  assign x__h3006 = weight_se_i__h2890[7] ? -x__h3022 : x__h3022 ;
  assign x__h3022 = { weight_se_i__h2890, weight_se_f__h2891 } ;
  assign x__h3025 = inp_se_i__h2974[7] ? -x__h3041 : x__h3041 ;
  assign x__h3041 = { inp_se_i__h2974, inp_se_f__h2975 } ;
  assign y_f__h3633 =
	     (IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d60[7] &&
	      (IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d60[31] ||
	       IF_SEL_ARR_m_weight_regs_0_2_BITS_15_TO_8_3_m__ETC___d60[6:0] !=
	       7'd0)) ?
	       8'd1 :
	       8'd0 ;
  always@(m_step or
	  m_weight_regs_0 or
	  m_weight_regs_1 or
	  m_weight_regs_2 or
	  m_weight_regs_3 or
	  m_weight_regs_4 or
	  m_weight_regs_5 or m_weight_regs_6 or m_weight_regs_7)
  begin
    case (m_step)
      4'd0: weight_se_i__h2890 = m_weight_regs_0[15:8];
      4'd1: weight_se_i__h2890 = m_weight_regs_1[15:8];
      4'd2: weight_se_i__h2890 = m_weight_regs_2[15:8];
      4'd3: weight_se_i__h2890 = m_weight_regs_3[15:8];
      4'd4: weight_se_i__h2890 = m_weight_regs_4[15:8];
      4'd5: weight_se_i__h2890 = m_weight_regs_5[15:8];
      4'd6: weight_se_i__h2890 = m_weight_regs_6[15:8];
      4'd7: weight_se_i__h2890 = m_weight_regs_7[15:8];
      default: weight_se_i__h2890 = 8'b10101010 /* unspecified value */ ;
    endcase
  end
  always@(m_step or
	  m_weight_regs_0 or
	  m_weight_regs_1 or
	  m_weight_regs_2 or
	  m_weight_regs_3 or
	  m_weight_regs_4 or
	  m_weight_regs_5 or m_weight_regs_6 or m_weight_regs_7)
  begin
    case (m_step)
      4'd0: weight_se_f__h2891 = m_weight_regs_0[7:0];
      4'd1: weight_se_f__h2891 = m_weight_regs_1[7:0];
      4'd2: weight_se_f__h2891 = m_weight_regs_2[7:0];
      4'd3: weight_se_f__h2891 = m_weight_regs_3[7:0];
      4'd4: weight_se_f__h2891 = m_weight_regs_4[7:0];
      4'd5: weight_se_f__h2891 = m_weight_regs_5[7:0];
      4'd6: weight_se_f__h2891 = m_weight_regs_6[7:0];
      4'd7: weight_se_f__h2891 = m_weight_regs_7[7:0];
      default: weight_se_f__h2891 = 8'b10101010 /* unspecified value */ ;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        m_partial_sum <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_step <= `BSV_ASSIGNMENT_DELAY 4'd0;
	m_weight_regs_0 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_weight_regs_1 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_weight_regs_2 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_weight_regs_3 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_weight_regs_4 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_weight_regs_5 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_weight_regs_6 <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_weight_regs_7 <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (m_partial_sum_EN)
	  m_partial_sum <= `BSV_ASSIGNMENT_DELAY m_partial_sum_D_IN;
	if (m_step_EN) m_step <= `BSV_ASSIGNMENT_DELAY m_step_D_IN;
	if (m_weight_regs_0_EN)
	  m_weight_regs_0 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_0_D_IN;
	if (m_weight_regs_1_EN)
	  m_weight_regs_1 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_1_D_IN;
	if (m_weight_regs_2_EN)
	  m_weight_regs_2 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_2_D_IN;
	if (m_weight_regs_3_EN)
	  m_weight_regs_3 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_3_D_IN;
	if (m_weight_regs_4_EN)
	  m_weight_regs_4 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_4_D_IN;
	if (m_weight_regs_5_EN)
	  m_weight_regs_5 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_5_D_IN;
	if (m_weight_regs_6_EN)
	  m_weight_regs_6 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_6_D_IN;
	if (m_weight_regs_7_EN)
	  m_weight_regs_7 <= `BSV_ASSIGNMENT_DELAY m_weight_regs_7_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_partial_sum = 16'hAAAA;
    m_step = 4'hA;
    m_weight_regs_0 = 16'hAAAA;
    m_weight_regs_1 = 16'hAAAA;
    m_weight_regs_2 = 16'hAAAA;
    m_weight_regs_3 = 16'hAAAA;
    m_weight_regs_4 = 16'hAAAA;
    m_weight_regs_5 = 16'hAAAA;
    m_weight_regs_6 = 16'hAAAA;
    m_weight_regs_7 = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkPEFP16

