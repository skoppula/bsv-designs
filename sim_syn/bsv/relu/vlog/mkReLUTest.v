//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Sun Dec 10 11:44:57 EST 2017
//
//
// Ports:
// Name                         I/O  size props
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkReLUTest;


  // register fin_fcount
  reg [31 : 0] fin_fcount;
  wire [31 : 0] fin_fcount_D_IN;
  wire fin_fcount_EN;

  // register stimulus_init
  reg stimulus_init;
  wire stimulus_init_D_IN, stimulus_init_EN;

  // register stimulus_rand_inp1_initialized
  reg stimulus_rand_inp1_initialized;
  wire stimulus_rand_inp1_initialized_D_IN, stimulus_rand_inp1_initialized_EN;

  // ports of submodule clk
  wire clk_CLK_OUT;

  // ports of submodule dut
  wire [31 : 0] dut_request_put, dut_response_get;
  wire dut_EN_request_put,
       dut_EN_response_get,
       dut_RDY_request_put,
       dut_RDY_response_get;

  // ports of submodule rstn
  wire rstn_OUT_RST;

  // ports of submodule stimulus_a
  wire [31 : 0] stimulus_a_D_IN;
  wire stimulus_a_CLR,
       stimulus_a_DEQ,
       stimulus_a_EMPTY_N,
       stimulus_a_ENQ,
       stimulus_a_FULL_N;

  // ports of submodule stimulus_golden_answer
  wire [31 : 0] stimulus_golden_answer_D_IN, stimulus_golden_answer_D_OUT;
  wire stimulus_golden_answer_CLR,
       stimulus_golden_answer_DEQ,
       stimulus_golden_answer_EMPTY_N,
       stimulus_golden_answer_ENQ,
       stimulus_golden_answer_FULL_N;

  // ports of submodule stimulus_rand_inp1
  wire [27 : 0] stimulus_rand_inp1_OUT;
  wire stimulus_rand_inp1_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_ClientServerRequest,
       CAN_FIRE_RL_ClientServerResponse,
       CAN_FIRE_RL_fin_fin,
       CAN_FIRE_RL_stimulus_do_init,
       CAN_FIRE_RL_stimulus_rand_inp1_every,
       WILL_FIRE_RL_ClientServerRequest,
       WILL_FIRE_RL_ClientServerResponse,
       WILL_FIRE_RL_fin_fin,
       WILL_FIRE_RL_stimulus_do_init,
       WILL_FIRE_RL_stimulus_rand_inp1_every;

  // remaining internal signals
  wire [27 : 0] stimulus_rand_inp1_next_REM_127___d12,
		stimulus_rand_inp1_next_REM_129___d14,
		stimulus_rand_inp1_next_REM_255___d16,
		stimulus_rand_inp1_next_REM_257___d18;

  // submodule clk
  ClockGen #(.v1Width(32'd3200),
	     .v2Width(32'd3200),
	     .initDelay(32'd0),
	     .initValue(32'd0),
	     .otherValue(32'd1)) clk(.CLK_OUT(clk_CLK_OUT));

  // submodule dut
  mkReLURNS dut(.CLK(clk_CLK_OUT),
		.RST_N(rstn_OUT_RST),
		.request_put(dut_request_put),
		.EN_request_put(dut_EN_request_put),
		.EN_response_get(dut_EN_response_get),
		.RDY_request_put(dut_RDY_request_put),
		.response_get(dut_response_get),
		.RDY_response_get(dut_RDY_response_get));

  // submodule rstn
  InitialReset #(.RSTHOLD(32'd2)) rstn(.CLK(clk_CLK_OUT),
				       .OUT_RST(rstn_OUT_RST));

  // submodule stimulus_a
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) stimulus_a(.RST(rstn_OUT_RST),
					  .CLK(clk_CLK_OUT),
					  .D_IN(stimulus_a_D_IN),
					  .ENQ(stimulus_a_ENQ),
					  .DEQ(stimulus_a_DEQ),
					  .CLR(stimulus_a_CLR),
					  .D_OUT(),
					  .FULL_N(stimulus_a_FULL_N),
					  .EMPTY_N(stimulus_a_EMPTY_N));

  // submodule stimulus_golden_answer
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) stimulus_golden_answer(.RST(rstn_OUT_RST),
						      .CLK(clk_CLK_OUT),
						      .D_IN(stimulus_golden_answer_D_IN),
						      .ENQ(stimulus_golden_answer_ENQ),
						      .DEQ(stimulus_golden_answer_DEQ),
						      .CLR(stimulus_golden_answer_CLR),
						      .D_OUT(stimulus_golden_answer_D_OUT),
						      .FULL_N(stimulus_golden_answer_FULL_N),
						      .EMPTY_N(stimulus_golden_answer_EMPTY_N));

  // submodule stimulus_rand_inp1
  ConstrainedRandom #(.width(32'd28),
		      .min(28'h0),
		      .max(28'd268435455)) stimulus_rand_inp1(.RST(rstn_OUT_RST),
							      .CLK(clk_CLK_OUT),
							      .EN(stimulus_rand_inp1_EN),
							      .OUT(stimulus_rand_inp1_OUT));

  // rule RL_ClientServerResponse
  assign CAN_FIRE_RL_ClientServerResponse =
	     dut_RDY_response_get && stimulus_golden_answer_EMPTY_N &&
	     stimulus_a_EMPTY_N ;
  assign WILL_FIRE_RL_ClientServerResponse =
	     CAN_FIRE_RL_ClientServerResponse ;

  // rule RL_ClientServerRequest
  assign CAN_FIRE_RL_ClientServerRequest =
	     dut_RDY_request_put && stimulus_rand_inp1_initialized &&
	     stimulus_a_FULL_N &&
	     stimulus_golden_answer_FULL_N ;
  assign WILL_FIRE_RL_ClientServerRequest = CAN_FIRE_RL_ClientServerRequest ;

  // rule RL_stimulus_rand_inp1_every
  assign CAN_FIRE_RL_stimulus_rand_inp1_every =
	     !stimulus_rand_inp1_initialized ;
  assign WILL_FIRE_RL_stimulus_rand_inp1_every =
	     CAN_FIRE_RL_stimulus_rand_inp1_every ;

  // rule RL_stimulus_do_init
  assign CAN_FIRE_RL_stimulus_do_init = !stimulus_init ;
  assign WILL_FIRE_RL_stimulus_do_init = CAN_FIRE_RL_stimulus_do_init ;

  // rule RL_fin_fin
  assign CAN_FIRE_RL_fin_fin = 1'd1 ;
  assign WILL_FIRE_RL_fin_fin = 1'd1 ;

  // register fin_fcount
  assign fin_fcount_D_IN = fin_fcount + 32'd1 ;
  assign fin_fcount_EN = 1'd1 ;

  // register stimulus_init
  assign stimulus_init_D_IN = 1'd1 ;
  assign stimulus_init_EN = CAN_FIRE_RL_stimulus_do_init ;

  // register stimulus_rand_inp1_initialized
  assign stimulus_rand_inp1_initialized_D_IN = 1'd1 ;
  assign stimulus_rand_inp1_initialized_EN = CAN_FIRE_RL_stimulus_do_init ;

  // submodule dut
  assign dut_request_put =
	     { stimulus_rand_inp1_next_REM_127___d12[6:0],
	       stimulus_rand_inp1_next_REM_129___d14[7:0],
	       stimulus_rand_inp1_next_REM_255___d16[7:0],
	       stimulus_rand_inp1_next_REM_257___d18[8:0] } ;
  assign dut_EN_request_put = CAN_FIRE_RL_ClientServerRequest ;
  assign dut_EN_response_get = CAN_FIRE_RL_ClientServerResponse ;

  // submodule stimulus_a
  assign stimulus_a_D_IN =
	     { stimulus_rand_inp1_next_REM_127___d12[6:0],
	       stimulus_rand_inp1_next_REM_129___d14[7:0],
	       stimulus_rand_inp1_next_REM_255___d16[7:0],
	       stimulus_rand_inp1_next_REM_257___d18[8:0] } ;
  assign stimulus_a_ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign stimulus_a_DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign stimulus_a_CLR = 1'b0 ;

  // submodule stimulus_golden_answer
  assign stimulus_golden_answer_D_IN =
	     (stimulus_rand_inp1_OUT <= 28'd178943316) ?
	       { stimulus_rand_inp1_next_REM_127___d12[6:0],
		 stimulus_rand_inp1_next_REM_129___d14[7:0],
		 stimulus_rand_inp1_next_REM_255___d16[7:0],
		 stimulus_rand_inp1_next_REM_257___d18[8:0] } :
	       32'h7E80FE80 ;
  assign stimulus_golden_answer_ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign stimulus_golden_answer_DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign stimulus_golden_answer_CLR = 1'b0 ;

  // submodule stimulus_rand_inp1
  assign stimulus_rand_inp1_EN =
	     WILL_FIRE_RL_ClientServerRequest ||
	     WILL_FIRE_RL_stimulus_rand_inp1_every ;

  // remaining internal signals
  assign stimulus_rand_inp1_next_REM_127___d12 =
	     stimulus_rand_inp1_OUT % 28'd127 ;
  assign stimulus_rand_inp1_next_REM_129___d14 =
	     stimulus_rand_inp1_OUT % 28'd129 ;
  assign stimulus_rand_inp1_next_REM_255___d16 =
	     stimulus_rand_inp1_OUT % 28'd255 ;
  assign stimulus_rand_inp1_next_REM_257___d18 =
	     stimulus_rand_inp1_OUT % 28'd257 ;

  // handling of inlined registers

  always@(posedge clk_CLK_OUT)
  begin
    if (rstn_OUT_RST == `BSV_RESET_VALUE)
      begin
        fin_fcount <= `BSV_ASSIGNMENT_DELAY 32'd0;
	stimulus_init <= `BSV_ASSIGNMENT_DELAY 1'd0;
	stimulus_rand_inp1_initialized <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (fin_fcount_EN)
	  fin_fcount <= `BSV_ASSIGNMENT_DELAY fin_fcount_D_IN;
	if (stimulus_init_EN)
	  stimulus_init <= `BSV_ASSIGNMENT_DELAY stimulus_init_D_IN;
	if (stimulus_rand_inp1_initialized_EN)
	  stimulus_rand_inp1_initialized <= `BSV_ASSIGNMENT_DELAY
	      stimulus_rand_inp1_initialized_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fin_fcount = 32'hAAAAAAAA;
    stimulus_init = 1'h0;
    stimulus_rand_inp1_initialized = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge clk_CLK_OUT)
  begin
    #0;
    if (rstn_OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_ClientServerResponse &&
	  (stimulus_golden_answer_D_OUT[31:25] != dut_response_get[31:25] ||
	   stimulus_golden_answer_D_OUT[24:17] != dut_response_get[24:17] ||
	   stimulus_golden_answer_D_OUT[16:9] != dut_response_get[16:9] ||
	   stimulus_golden_answer_D_OUT[8:0] != dut_response_get[8:0]))
	$display("FAIL relu");
    if (rstn_OUT_RST != `BSV_RESET_VALUE)
      if (fin_fcount == 32'd1000) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mkReLUTest

