//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Thu Jul 13 18:53:14 EDT 2017
//
//
// Ports:
// Name                         I/O  size props
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkSimML605Test;


  // inlined wires
  wire transrecFSM_start_wire$whas, transrecFSM_state_set_pw$whas;

  // register cnt
  reg [31 : 0] cnt;
  wire [31 : 0] cnt$D_IN;
  wire cnt$EN;

  // register transrecFSM_start_reg
  reg transrecFSM_start_reg;
  wire transrecFSM_start_reg$D_IN, transrecFSM_start_reg$EN;

  // register transrecFSM_start_reg_1
  reg transrecFSM_start_reg_1;
  wire transrecFSM_start_reg_1$D_IN, transrecFSM_start_reg_1$EN;

  // register transrecFSM_state_can_overlap
  reg transrecFSM_state_can_overlap;
  wire transrecFSM_state_can_overlap$D_IN, transrecFSM_state_can_overlap$EN;

  // register transrecFSM_state_fired
  reg transrecFSM_state_fired;
  wire transrecFSM_state_fired$D_IN, transrecFSM_state_fired$EN;

  // register transrecFSM_state_mkFSMstate
  reg [3 : 0] transrecFSM_state_mkFSMstate;
  reg [3 : 0] transrecFSM_state_mkFSMstate$D_IN;
  wire transrecFSM_state_mkFSMstate$EN;

  // register x
  reg [15 : 0] x;
  wire [15 : 0] x$D_IN;
  wire x$EN;

  // register x_rec
  reg [15 : 0] x_rec;
  wire [15 : 0] x_rec$D_IN;
  wire x_rec$EN;

  // register y
  reg [15 : 0] y;
  wire [15 : 0] y$D_IN;
  wire y$EN;

  // register y_rec
  reg [15 : 0] y_rec;
  wire [15 : 0] y_rec$D_IN;
  wire y_rec$EN;

  // ports of submodule clk66
  wire clk66$CLK_OUT;

  // ports of submodule dut
  wire dut$uart_cts, dut$uart_rts, dut$uart_rxd, dut$uart_txd;

  // ports of submodule rst
  wire rst$RESET_OUT;

  // ports of submodule rst_n
  wire rst_n$OUT_RST;

  // ports of submodule uart
  wire [7 : 0] uart$rx, uart$tx_i;
  wire uart$EN_clear,
       uart$EN_rx,
       uart$EN_tx,
       uart$RDY_rx,
       uart$RDY_tx,
       uart$pins_cts,
       uart$pins_rts,
       uart$pins_rxd,
       uart$pins_txd;

  // rule scheduling signals
  wire CAN_FIRE_RL_check,
       CAN_FIRE_RL_pin_connection,
       CAN_FIRE_RL_startit,
       CAN_FIRE_RL_transrecFSM_action_l30c17,
       CAN_FIRE_RL_transrecFSM_action_l35c17,
       CAN_FIRE_RL_transrecFSM_action_l38c17,
       CAN_FIRE_RL_transrecFSM_action_l42c9,
       CAN_FIRE_RL_transrecFSM_action_l46c9,
       CAN_FIRE_RL_transrecFSM_action_l52c9,
       CAN_FIRE_RL_transrecFSM_action_l56c9,
       CAN_FIRE_RL_transrecFSM_fsm_start,
       CAN_FIRE_RL_transrecFSM_idle_l29c9,
       CAN_FIRE_RL_transrecFSM_restart,
       CAN_FIRE_RL_transrecFSM_start_reg__dreg_update,
       CAN_FIRE_RL_transrecFSM_state_every,
       CAN_FIRE_RL_transrecFSM_state_fired__dreg_update,
       CAN_FIRE_RL_transrecFSM_state_handle_abort,
       CAN_FIRE___me_check_10,
       CAN_FIRE___me_check_5,
       CAN_FIRE___me_check_6,
       CAN_FIRE___me_check_7,
       CAN_FIRE___me_check_8,
       CAN_FIRE___me_check_9,
       WILL_FIRE_RL_check,
       WILL_FIRE_RL_pin_connection,
       WILL_FIRE_RL_startit,
       WILL_FIRE_RL_transrecFSM_action_l30c17,
       WILL_FIRE_RL_transrecFSM_action_l35c17,
       WILL_FIRE_RL_transrecFSM_action_l38c17,
       WILL_FIRE_RL_transrecFSM_action_l42c9,
       WILL_FIRE_RL_transrecFSM_action_l46c9,
       WILL_FIRE_RL_transrecFSM_action_l52c9,
       WILL_FIRE_RL_transrecFSM_action_l56c9,
       WILL_FIRE_RL_transrecFSM_fsm_start,
       WILL_FIRE_RL_transrecFSM_idle_l29c9,
       WILL_FIRE_RL_transrecFSM_restart,
       WILL_FIRE_RL_transrecFSM_start_reg__dreg_update,
       WILL_FIRE_RL_transrecFSM_state_every,
       WILL_FIRE_RL_transrecFSM_state_fired__dreg_update,
       WILL_FIRE_RL_transrecFSM_state_handle_abort,
       WILL_FIRE___me_check_10,
       WILL_FIRE___me_check_5,
       WILL_FIRE___me_check_6,
       WILL_FIRE___me_check_7,
       WILL_FIRE___me_check_8,
       WILL_FIRE___me_check_9;

  // inputs to muxes for submodule ports
  wire [15 : 0] MUX_x_rec$write_1__VAL_2;
  wire MUX_uart$tx_1__SEL_1, MUX_uart$tx_1__SEL_2;

  // remaining internal signals
  reg [63 : 0] v__h13454, v__h13941, v__h14483;
  wire [15 : 0] x_PLUS_2__q1, xtmp__h13927, ytmp__h14469;
  wire transrecFSM_abort_whas_AND_transrecFSM_abort_w_ETC___d80;

  // submodule clk66
  ClockGen #(.v1Width(32'd7),
	     .v2Width(32'd8),
	     .initDelay(32'd0),
	     .initValue(32'd0),
	     .otherValue(32'd1)) clk66(.CLK_OUT(clk66$CLK_OUT));

  // submodule dut
  mkML605Test dut(.CLK(clk66$CLK_OUT),
		  .RST_N(rst$RESET_OUT),
		  .uart_cts(dut$uart_cts),
		  .uart_rxd(dut$uart_rxd),
		  .uart_txd(dut$uart_txd),
		  .uart_rts(dut$uart_rts),
		  .leds());

  // submodule rst
  ResetInverter rst(.RESET_IN(rst_n$OUT_RST), .RESET_OUT(rst$RESET_OUT));

  // submodule rst_n
  InitialReset #(.RSTHOLD(32'd10)) rst_n(.CLK(clk66$CLK_OUT),
					 .OUT_RST(rst_n$OUT_RST));

  // submodule uart
  mkUARTSpec uart(.cfg(19'd1146),
		  .CLK(clk66$CLK_OUT),
		  .RST_N(rst_n$OUT_RST),
		  .pins_cts(uart$pins_cts),
		  .pins_rxd(uart$pins_rxd),
		  .tx_i(uart$tx_i),
		  .EN_rx(uart$EN_rx),
		  .EN_tx(uart$EN_tx),
		  .EN_clear(uart$EN_clear),
		  .pins_txd(uart$pins_txd),
		  .pins_rts(uart$pins_rts),
		  .rx_first(),
		  .RDY_rx_first(),
		  .rx(uart$rx),
		  .RDY_rx(uart$RDY_rx),
		  .RDY_tx(uart$RDY_tx),
		  .RDY_clear(),
		  .errors());

  // rule RL_check
  assign CAN_FIRE_RL_check =
	     transrecFSM_abort_whas_AND_transrecFSM_abort_w_ETC___d80 &&
	     !transrecFSM_start_reg ;
  assign WILL_FIRE_RL_check = CAN_FIRE_RL_check ;

  // rule RL_startit
  assign CAN_FIRE_RL_startit =
	     transrecFSM_abort_whas_AND_transrecFSM_abort_w_ETC___d80 &&
	     !transrecFSM_start_reg &&
	     (cnt ^ 32'h80000000) < 32'h80000008 ;
  assign WILL_FIRE_RL_startit = CAN_FIRE_RL_startit ;

  // rule RL_pin_connection
  assign CAN_FIRE_RL_pin_connection = 1'd1 ;
  assign WILL_FIRE_RL_pin_connection = 1'd1 ;

  // rule RL_transrecFSM_restart
  assign CAN_FIRE_RL_transrecFSM_restart =
	     transrecFSM_start_reg_1 && !transrecFSM_state_fired ;
  assign WILL_FIRE_RL_transrecFSM_restart = CAN_FIRE_RL_transrecFSM_restart ;

  // rule RL_transrecFSM_action_l35c17
  assign CAN_FIRE_RL_transrecFSM_action_l35c17 = MUX_uart$tx_1__SEL_2 ;
  assign WILL_FIRE_RL_transrecFSM_action_l35c17 = MUX_uart$tx_1__SEL_2 ;

  // rule RL_transrecFSM_action_l38c17
  assign CAN_FIRE_RL_transrecFSM_action_l38c17 = MUX_uart$tx_1__SEL_1 ;
  assign WILL_FIRE_RL_transrecFSM_action_l38c17 = MUX_uart$tx_1__SEL_1 ;

  // rule RL_transrecFSM_action_l42c9
  assign CAN_FIRE_RL_transrecFSM_action_l42c9 =
	     uart$RDY_rx && transrecFSM_state_mkFSMstate == 4'd3 ;
  assign WILL_FIRE_RL_transrecFSM_action_l42c9 =
	     CAN_FIRE_RL_transrecFSM_action_l42c9 ;

  // rule RL_transrecFSM_action_l46c9
  assign CAN_FIRE_RL_transrecFSM_action_l46c9 =
	     uart$RDY_rx && transrecFSM_state_mkFSMstate == 4'd4 ;
  assign WILL_FIRE_RL_transrecFSM_action_l46c9 =
	     CAN_FIRE_RL_transrecFSM_action_l46c9 ;

  // rule RL_transrecFSM_action_l52c9
  assign CAN_FIRE_RL_transrecFSM_action_l52c9 =
	     uart$RDY_rx && transrecFSM_state_mkFSMstate == 4'd5 ;
  assign WILL_FIRE_RL_transrecFSM_action_l52c9 =
	     CAN_FIRE_RL_transrecFSM_action_l52c9 ;

  // rule RL_transrecFSM_action_l56c9
  assign CAN_FIRE_RL_transrecFSM_action_l56c9 =
	     uart$RDY_rx && transrecFSM_state_mkFSMstate == 4'd6 ;
  assign WILL_FIRE_RL_transrecFSM_action_l56c9 =
	     CAN_FIRE_RL_transrecFSM_action_l56c9 ;

  // rule __me_check_6
  assign CAN_FIRE___me_check_6 = 1'b1 ;
  assign WILL_FIRE___me_check_6 = 1'b1 ;

  // rule __me_check_7
  assign CAN_FIRE___me_check_7 = 1'b1 ;
  assign WILL_FIRE___me_check_7 = 1'b1 ;

  // rule __me_check_8
  assign CAN_FIRE___me_check_8 = 1'b1 ;
  assign WILL_FIRE___me_check_8 = 1'b1 ;

  // rule __me_check_9
  assign CAN_FIRE___me_check_9 = 1'b1 ;
  assign WILL_FIRE___me_check_9 = 1'b1 ;

  // rule __me_check_10
  assign CAN_FIRE___me_check_10 = 1'b1 ;
  assign WILL_FIRE___me_check_10 = 1'b1 ;

  // rule RL_transrecFSM_fsm_start
  assign CAN_FIRE_RL_transrecFSM_fsm_start =
	     transrecFSM_abort_whas_AND_transrecFSM_abort_w_ETC___d80 &&
	     transrecFSM_start_reg ;
  assign WILL_FIRE_RL_transrecFSM_fsm_start =
	     CAN_FIRE_RL_transrecFSM_fsm_start ;

  // rule RL_transrecFSM_action_l30c17
  assign CAN_FIRE_RL_transrecFSM_action_l30c17 =
	     transrecFSM_start_wire$whas &&
	     (transrecFSM_state_mkFSMstate == 4'd0 ||
	      transrecFSM_state_mkFSMstate == 4'd7) ;
  assign WILL_FIRE_RL_transrecFSM_action_l30c17 =
	     CAN_FIRE_RL_transrecFSM_action_l30c17 ;

  // rule __me_check_5
  assign CAN_FIRE___me_check_5 = 1'b1 ;
  assign WILL_FIRE___me_check_5 = 1'b1 ;

  // rule RL_transrecFSM_idle_l29c9
  assign CAN_FIRE_RL_transrecFSM_idle_l29c9 =
	     !transrecFSM_start_wire$whas &&
	     transrecFSM_state_mkFSMstate == 4'd7 ;
  assign WILL_FIRE_RL_transrecFSM_idle_l29c9 =
	     CAN_FIRE_RL_transrecFSM_idle_l29c9 ;

  // rule RL_transrecFSM_start_reg__dreg_update
  assign CAN_FIRE_RL_transrecFSM_start_reg__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_transrecFSM_start_reg__dreg_update = 1'd1 ;

  // rule RL_transrecFSM_state_handle_abort
  assign CAN_FIRE_RL_transrecFSM_state_handle_abort = 1'b0 ;
  assign WILL_FIRE_RL_transrecFSM_state_handle_abort = 1'b0 ;

  // rule RL_transrecFSM_state_every
  assign CAN_FIRE_RL_transrecFSM_state_every = 1'd1 ;
  assign WILL_FIRE_RL_transrecFSM_state_every = 1'd1 ;

  // rule RL_transrecFSM_state_fired__dreg_update
  assign CAN_FIRE_RL_transrecFSM_state_fired__dreg_update = 1'd1 ;
  assign WILL_FIRE_RL_transrecFSM_state_fired__dreg_update = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_uart$tx_1__SEL_1 =
	     uart$RDY_tx && transrecFSM_state_mkFSMstate == 4'd2 ;
  assign MUX_uart$tx_1__SEL_2 =
	     uart$RDY_tx && transrecFSM_state_mkFSMstate == 4'd1 ;
  assign MUX_x_rec$write_1__VAL_2 = { uart$rx, 8'b0 } ;

  // inlined wires
  assign transrecFSM_start_wire$whas =
	     WILL_FIRE_RL_transrecFSM_fsm_start ||
	     WILL_FIRE_RL_transrecFSM_restart ;
  assign transrecFSM_state_set_pw$whas =
	     WILL_FIRE_RL_transrecFSM_idle_l29c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l56c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l42c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l38c17 ||
	     WILL_FIRE_RL_transrecFSM_action_l35c17 ||
	     WILL_FIRE_RL_transrecFSM_action_l30c17 ;

  // register cnt
  assign cnt$D_IN = cnt + 32'd1 ;
  assign cnt$EN = CAN_FIRE_RL_startit ;

  // register transrecFSM_start_reg
  assign transrecFSM_start_reg$D_IN = !WILL_FIRE_RL_transrecFSM_fsm_start ;
  assign transrecFSM_start_reg$EN =
	     WILL_FIRE_RL_transrecFSM_fsm_start || WILL_FIRE_RL_startit ;

  // register transrecFSM_start_reg_1
  assign transrecFSM_start_reg_1$D_IN = transrecFSM_start_wire$whas ;
  assign transrecFSM_start_reg_1$EN = 1'd1 ;

  // register transrecFSM_state_can_overlap
  assign transrecFSM_state_can_overlap$D_IN =
	     transrecFSM_state_set_pw$whas || transrecFSM_state_can_overlap ;
  assign transrecFSM_state_can_overlap$EN = 1'd1 ;

  // register transrecFSM_state_fired
  assign transrecFSM_state_fired$D_IN = transrecFSM_state_set_pw$whas ;
  assign transrecFSM_state_fired$EN = 1'd1 ;

  // register transrecFSM_state_mkFSMstate
  always@(WILL_FIRE_RL_transrecFSM_idle_l29c9 or
	  WILL_FIRE_RL_transrecFSM_action_l30c17 or
	  WILL_FIRE_RL_transrecFSM_action_l35c17 or
	  WILL_FIRE_RL_transrecFSM_action_l38c17 or
	  WILL_FIRE_RL_transrecFSM_action_l42c9 or
	  WILL_FIRE_RL_transrecFSM_action_l46c9 or
	  WILL_FIRE_RL_transrecFSM_action_l52c9 or
	  WILL_FIRE_RL_transrecFSM_action_l56c9)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_transrecFSM_idle_l29c9:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd0;
      WILL_FIRE_RL_transrecFSM_action_l30c17:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_transrecFSM_action_l35c17:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd2;
      WILL_FIRE_RL_transrecFSM_action_l38c17:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd3;
      WILL_FIRE_RL_transrecFSM_action_l42c9:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd4;
      WILL_FIRE_RL_transrecFSM_action_l46c9:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd5;
      WILL_FIRE_RL_transrecFSM_action_l52c9:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd6;
      WILL_FIRE_RL_transrecFSM_action_l56c9:
	  transrecFSM_state_mkFSMstate$D_IN = 4'd7;
      default: transrecFSM_state_mkFSMstate$D_IN =
		   4'b1010 /* unspecified value */ ;
    endcase
  end
  assign transrecFSM_state_mkFSMstate$EN =
	     WILL_FIRE_RL_transrecFSM_idle_l29c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l30c17 ||
	     WILL_FIRE_RL_transrecFSM_action_l35c17 ||
	     WILL_FIRE_RL_transrecFSM_action_l38c17 ||
	     WILL_FIRE_RL_transrecFSM_action_l42c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l56c9 ;

  // register x
  assign x$D_IN = { 1'b1, x_PLUS_2__q1[14:0] } ;
  assign x$EN = CAN_FIRE_RL_transrecFSM_action_l30c17 ;

  // register x_rec
  assign x_rec$D_IN =
	     WILL_FIRE_RL_transrecFSM_action_l46c9 ?
	       xtmp__h13927 :
	       MUX_x_rec$write_1__VAL_2 ;
  assign x_rec$EN =
	     WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l42c9 ;

  // register y
  assign y$D_IN = y + 16'd1 ;
  assign y$EN = CAN_FIRE_RL_transrecFSM_action_l30c17 ;

  // register y_rec
  assign y_rec$D_IN =
	     WILL_FIRE_RL_transrecFSM_action_l52c9 ?
	       MUX_x_rec$write_1__VAL_2 :
	       ytmp__h14469 ;
  assign y_rec$EN =
	     WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l56c9 ;

  // submodule dut
  assign dut$uart_cts = uart$pins_rts ;
  assign dut$uart_rxd = uart$pins_txd ;

  // submodule uart
  assign uart$pins_cts = dut$uart_rts ;
  assign uart$pins_rxd = dut$uart_txd ;
  assign uart$tx_i =
	     WILL_FIRE_RL_transrecFSM_action_l38c17 ? x[7:0] : x[15:8] ;
  assign uart$EN_rx =
	     WILL_FIRE_RL_transrecFSM_action_l56c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	     WILL_FIRE_RL_transrecFSM_action_l42c9 ;
  assign uart$EN_tx =
	     WILL_FIRE_RL_transrecFSM_action_l38c17 ||
	     WILL_FIRE_RL_transrecFSM_action_l35c17 ;
  assign uart$EN_clear = 1'b0 ;

  // remaining internal signals
  assign transrecFSM_abort_whas_AND_transrecFSM_abort_w_ETC___d80 =
	     (transrecFSM_state_mkFSMstate == 4'd0 ||
	      transrecFSM_state_mkFSMstate == 4'd7) &&
	     (!transrecFSM_start_reg_1 || transrecFSM_state_fired) ;
  assign x_PLUS_2__q1 = x + 16'd2 ;
  assign xtmp__h13927 = { x_rec[15:8], uart$rx } ;
  assign ytmp__h14469 = { y_rec[15:8], uart$rx } ;

  // handling of inlined registers

  always@(posedge clk66$CLK_OUT)
  begin
    if (rst_n$OUT_RST == `BSV_RESET_VALUE)
      begin
        cnt <= `BSV_ASSIGNMENT_DELAY 32'd0;
	transrecFSM_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	transrecFSM_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	transrecFSM_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	transrecFSM_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	transrecFSM_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	x <= `BSV_ASSIGNMENT_DELAY 16'd0;
	x_rec <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
	y <= `BSV_ASSIGNMENT_DELAY 16'd0;
	y_rec <= `BSV_ASSIGNMENT_DELAY 16'hAAAA;
      end
    else
      begin
        if (cnt$EN) cnt <= `BSV_ASSIGNMENT_DELAY cnt$D_IN;
	if (transrecFSM_start_reg$EN)
	  transrecFSM_start_reg <= `BSV_ASSIGNMENT_DELAY
	      transrecFSM_start_reg$D_IN;
	if (transrecFSM_start_reg_1$EN)
	  transrecFSM_start_reg_1 <= `BSV_ASSIGNMENT_DELAY
	      transrecFSM_start_reg_1$D_IN;
	if (transrecFSM_state_can_overlap$EN)
	  transrecFSM_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      transrecFSM_state_can_overlap$D_IN;
	if (transrecFSM_state_fired$EN)
	  transrecFSM_state_fired <= `BSV_ASSIGNMENT_DELAY
	      transrecFSM_state_fired$D_IN;
	if (transrecFSM_state_mkFSMstate$EN)
	  transrecFSM_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      transrecFSM_state_mkFSMstate$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
	if (x_rec$EN) x_rec <= `BSV_ASSIGNMENT_DELAY x_rec$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
	if (y_rec$EN) y_rec <= `BSV_ASSIGNMENT_DELAY y_rec$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cnt = 32'hAAAAAAAA;
    transrecFSM_start_reg = 1'h0;
    transrecFSM_start_reg_1 = 1'h0;
    transrecFSM_state_can_overlap = 1'h0;
    transrecFSM_state_fired = 1'h0;
    transrecFSM_state_mkFSMstate = 4'hA;
    x = 16'hAAAA;
    x_rec = 16'hAAAA;
    y = 16'hAAAA;
    y_rec = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge clk66$CLK_OUT)
  begin
    #0;
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_check && x != x_rec)
	$display("testing mismatches in features (UART ERROR)");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_check && y != y_rec)
	$display("testing mismatches in weights (UART ERROR)");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_startit) $display("sim fsm start");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l38c17)
	begin
	  v__h13454 = $time;
	  #0;
	end
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l38c17)
	$write(v__h13454,
	       "     %m.",
	       "testing uart transmitted feature",
	       "\t");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l38c17) $write("'h%h", x);
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l38c17) $write("\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l46c9)
	begin
	  v__h13941 = $time;
	  #0;
	end
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l46c9)
	$write(v__h13941, "     %m.", "testing uart received features", "\t");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l46c9) $write("'h%h", xtmp__h13927);
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l46c9) $write("\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l56c9)
	begin
	  v__h14483 = $time;
	  #0;
	end
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l56c9)
	$write(v__h14483, "     %m.", "testing uart received weights", "\t");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l56c9) $write("'h%h", ytmp__h14469);
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l56c9) $write("\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l35c17 &&
	  (WILL_FIRE_RL_transrecFSM_action_l38c17 ||
	   WILL_FIRE_RL_transrecFSM_action_l42c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l56c9))
	$display("Error: \"../SimML605Test.bsv\", line 35, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_transrecFSM_action_l35c17]\n  and [RL_transrecFSM_action_l38c17, RL_transrecFSM_action_l42c9,\n  RL_transrecFSM_action_l46c9, RL_transrecFSM_action_l52c9,\n  RL_transrecFSM_action_l56c9] ) fired in the same clock cycle.\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l38c17 &&
	  (WILL_FIRE_RL_transrecFSM_action_l42c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l56c9))
	$display("Error: \"../SimML605Test.bsv\", line 38, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_transrecFSM_action_l38c17]\n  and [RL_transrecFSM_action_l42c9, RL_transrecFSM_action_l46c9,\n  RL_transrecFSM_action_l52c9, RL_transrecFSM_action_l56c9] ) fired in the\n  same clock cycle.\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l42c9 &&
	  (WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l56c9))
	$display("Error: \"../SimML605Test.bsv\", line 42, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_transrecFSM_action_l42c9] and\n  [RL_transrecFSM_action_l46c9, RL_transrecFSM_action_l52c9,\n  RL_transrecFSM_action_l56c9] ) fired in the same clock cycle.\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l46c9 &&
	  (WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l56c9))
	$display("Error: \"../SimML605Test.bsv\", line 46, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_transrecFSM_action_l46c9] and\n  [RL_transrecFSM_action_l52c9, RL_transrecFSM_action_l56c9] ) fired in the\n  same clock cycle.\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l52c9 &&
	  WILL_FIRE_RL_transrecFSM_action_l56c9)
	$display("Error: \"../SimML605Test.bsv\", line 52, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_transrecFSM_action_l52c9] and\n  [RL_transrecFSM_action_l56c9] ) fired in the same clock cycle.\n");
    if (rst_n$OUT_RST != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_transrecFSM_action_l30c17 &&
	  (WILL_FIRE_RL_transrecFSM_action_l35c17 ||
	   WILL_FIRE_RL_transrecFSM_action_l38c17 ||
	   WILL_FIRE_RL_transrecFSM_action_l42c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l46c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l52c9 ||
	   WILL_FIRE_RL_transrecFSM_action_l56c9))
	$display("Error: \"../SimML605Test.bsv\", line 30, column 17: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_transrecFSM_action_l30c17]\n  and [RL_transrecFSM_action_l35c17, RL_transrecFSM_action_l38c17,\n  RL_transrecFSM_action_l42c9, RL_transrecFSM_action_l46c9,\n  RL_transrecFSM_action_l52c9, RL_transrecFSM_action_l56c9] ) fired in the\n  same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkSimML605Test

